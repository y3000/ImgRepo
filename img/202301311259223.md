#    前端面试题目

## 题目分类

- HTTP，HTML，浏览器
- jQuery
- 流行框架
- 计算机网络
- **算法与数据结构**
- 场景题
- **CSS**
- BootStrap
- Node.js
- 操作系统
- 设计模式
- **JavaScript**
- 前端工作流
- react
- 数据库
- 智力题

![image-20220206164851683](C:\Users\86153\AppData\Roaming\Typora\typora-user-images\image-20220206164851683.png)

## 面试小技巧

1. 简历上做好引导，注意用词，比如熟悉C/C++,了解python，精通HTML，css
2. 面试过程中尽量引导到自己熟知的一个领域。
3. 在面试开头自我介绍中做一个优势方向引导
4. 项目和算法很重要



## 思维导图：

![前端面试思维导图](https://cdn.jsdelivr.net/gh/y3000/ImgRepo/img/202301311253292.png)



![img](https://cdn.jsdelivr.net/gh/y3000/ImgRepo/img/202301311253662.png)

## 一、前端基础

### 1.1 浏览器

#### 1.1.1 http和HTTPS

(1)**基本概念：**

**HTTP**：超文本传输协议，是一个客户端和服务器端请求和应答的标准（TCP），用于从WWW服务器传输超文本到本地浏览器的传输协议，常基于TCP/IP协议传输数据。

http 是基于 tcp 协议的一个[应用层](https://so.csdn.net/so/search?q=应用层&spm=1001.2101.3001.7020)的协议,是一个无状态的协议。

优点：简单、灵活、应用广泛和跨平台。

缺点：无状态、明文传输、不安全

**HTTPS**：https 就是加密的 http ，它通过 http 进行通信，**利用 SSL/TLS 建立安全信道**，加密数据包。

`HTTPS`使用的主要目的是提供对网站服务器的身份认证，同时保护交换数据的**隐私与完整性**。（**TLS是传输层加密协议，前身是SSL协议**）

SSL/TLS 协议是 HTTP 与 TCP 之间的安全协议，可以验证服务器的身份，为客户端和服务端之间的通信加密，并且保证信息的完整性。



(2) **HTTP和HTTPS 的区别**

- HTTP传输的数据是 **未加密的，明文的**，https则是具有安全性的SSL加密传输协议HTTPS 协议是由http和ssl协议构建的可进行**加密传输和身份认证**的网络协议，**安全性更高**。

- HTTP的端口是80 HTTPS的端口的443 

- HTTPS 协议需要向 CA（证书权威机构）申请数字证书，来保证服务器的身份是可信的。

- HTTP建立TCP三次握手后就可以传输数据，https在TCP三次握手后还需要进行SSL/TSL 握手过程，才可进入加密报文传输

  



（3）**HTTPS的优缺点**

优点：安全性高、确保数据完整性、

且在谷歌的搜索引擎算法中，“比起同等的HTTP网站，采用HTTPs加密 的网站，在搜索结果中的排名将会更高”

缺点：HTTPS握手阶段比较费时，缓存不如HTTP高效，SSL证书要钱

（4）**HTTP请求/响应步骤**

**客户端连接到Web服务器->发送Http请求->服务器接受请求并返回HTTP响应->释放连接TCP连接->客户端浏览器解析HTML内容**

域名解析 --> 发起TCP的3次握手 --> 建立TCP连接后发起http请求 --> 服务器响应http请求，浏览器得到html代码 --> 浏览器解析html代码，并请求html代码中的资源（如js、css、图片等） --> 浏览器对页面进行渲染呈现给用户

##### https实现原理 如何建立连接？

1. 客户端发起https请求，把自己支持的加密规则（加密算法和哈希算法）发送给端口为443的服务器；

2. 服务器从浏览器发送过来的加密规则中选用，然后将数字证书返回；

3. 客户端对证书进行验证，验证通过后，随机生成一个密钥R，通过证书中的公钥对密钥R进行加密（非对称加密），传输给服务端

   ***验证方式：***

   - 先验证证书的合法性，如果合法的话，取出公钥并用公钥**解密**得到证书的**签名**和内容；
     - 合法性验证：检查证书是否过期，证书机构是否在受信任的名单中、证书有没有被吊销、审核证书中的网站域名是否一致、该网站是否在欺诈黑名单中
   - 再验证证书签名的合法性；

4. 服务端接收到后用私钥解密取出密钥R，并用密钥R对网页内容进行加密再传输给浏览器，之后的数据传输都通过对称加密算法进行加密解密。

![1658585903074](https://cdn.jsdelivr.net/gh/y3000/ImgRepo/img/202301311251325.png)



##### 加密方式

- 对称加密：加密和解密的密钥是相同的
- 非对称加密：加密和解密使用不同的密钥的加密算法；公钥和私钥是一对，只有公钥对应的私钥能解密；安全性较高，但解密速度比对称加密慢

> 浏览器 ：结合对称加密+非对称加密这两种方式，我们可以用非对称加密的方式来传输对称加密过程中的密钥，之后我们就可以采取对称加密的方式来传输数据了。

- 数字证书与数字签名

##### HTTPS中间人攻击

1.服务器向客户端发送公钥

2.攻击者截获公钥，保留在自己手上

3.攻击者自己生成的伪造公钥，发送给客户端

4.客户端收到伪造的公钥，生成加密的密钥发送给服务器

5.攻击者截获后用自己私钥解密获得真密钥，同时生成一个假的密钥发送给服务器端

6.服务器用私钥解密获得假密钥，然后通过假密钥加密传输信息

**防范措施：**

服务器在发送浏览器的公钥中加入 CA 证书，浏览器可以验证 CA 证书的有效性；（现有 HTTPS 很难被劫持，除非信任了劫持者的 CA 证书）。

配置路由规则，绑定 IP／MAC 以防被 ARP 欺骗。

##### http 常见字段

请求报文包含三部分：

- 请求行：包含请求方法、URI、HTTP版本信息；
- 请求首部字段；
- 请求内容实体。

content-type

Host

Connection

<img src="https://cdn.jsdelivr.net/gh/y3000/ImgRepo/img/202301311258164.png" alt="1661909703594"  />



#### 1.1.2 说一下http2.0

http1.1更新了什么？

> - 使用TCP长连接
> - 支持管道网络传输，只要第一个请求发出去了，不必等待响应就可以发送第二个请求。

主要更新了：
**提升访问速度；**

**允许多路复用；**

HTTP/2 复用TCP连接，在一个连接里，客户端和浏览器都可以同时发送多个请求或回应，而且不用按照顺序一一对应，这样就避免了”队头堵塞”。

**二进制分帧(1.0是文本字符串传送)；**

 HTTP/2 会将所有传输的信息分割为帧（frame）,并对它们采用二进制格式的编码。

**首部压缩；**

一方面，头信息使用gzip或compress压缩后再发送；
另一方面，客户端和服务器同时维护一张头信息表，所有字段都会存入这个表，产生一个索引号，之后就不发送同样字段了，只需发送索引号。

数据体积小了，在网络上传输就会更快。

**服务器端推送；**

服务器推送服务通过“推送”那些它认为客户端将会需要的内容到客户端的缓存中，以此来避免往返的延迟。

服务器可以对客户端的一个请求发送多个响应。因此当客户端需要的数据已缓存时，客户端直接从本地加载这些资源就可以了，不用走网络，速度自然是快很多的。

#### 1.1.3 TCP三次握手 概括

三次握手：
![](https://user-images.githubusercontent.com/17233651/42496289-1c6d668a-8458-11e8-98b3-65db50f64d48.png)

A与B 建立TCP连接时

第一次握手：A向B发起SYN（同步请求）

第二次握手：B回复SYN+ACK(同步请求应答)

第三次握手：A回复ACK确认

建立连接 传输数据。

> 第一次：建立连接，客户端发送 SYN 包（SYN=i）到服务器，并进入 SYN_SEND 状态，等待服务器确认；
> 第二次：服务器接收 SYN 包，确认客户的 SYN ,同时也发送一个 SYN 包（SYN=k）+ ACK 包（ACK = i+1）给客户端，服务器进入 SYN_RECV 状态；
> 第三次：客户端接收到服务器的 SYN+ACK 包之后，同时向服务器发送确认包 ACK 包（ACK = k+1）,然后客户端和服务器进入ESTABLISHED 状态。

![1656489072545](../../source/images/前端面试/1656489072545.png)

![1656489155863](../../source/images/前端面试/1656489155863.png)

##### 四次挥手

> **第一次：**客户端发送一个 FIN（i） ，用来关闭客户端和服务器的数据传输，客户端进入 FIN_WAIT_1 状态；
> **第二次：**服务器接收 FIN ，发送一个 ACK （i+1）给客户端，服务器进入 CLISE_WAIT 状态；
> **第三次：**服务器发送一个 FIN （j） 给客户端用来关闭服务器到客户端的数据传输，服务器进入 LAST_ACK 状态；
> **第四次：**客户端接收到 FIN 后，客户端进入 TIME_WAIT 状态，然后发送 ACK （j+1） 给服务器，校验完成之后服务器进入 CLOSED 状态。
>
> ![这里写图片描述](../../source/images/前端面试/20180718083935737.png)

![img](../../source/images/前端面试/3971776-94d00c471d74148f.webp)

##### 为什么握手是三次，挥手是四次？

三次握手的目的是建立可靠的信道，确认客户端和服务器端双方都发送和接收数据都正常；

四次挥手是因为在一方发出释放连接的通知后，等待对方的确认后进入半关闭状态，此时还是可以接收数据的，当另一方数据发送完毕没有数据发送了就发出释放连接的通知，等待主动关闭的一方确认后就完全关闭TCP连接。

#### 1.1.4 TCP和UDP的区别

1. TCP是面向连接的，UDP是无连接的，即发送数据前不需要先建立连接

2. TCP提供可靠服务，传输数据无差错，不丢失，按序到达；UDP尽最大努力交付，不保证可靠交付。

3. TCP面向字节流，UDP面向报文（IP电话和视频会议应用）

4. TCP1对1，UDP支持1对多

5. TCP首部较大，20字节；UDP首部只有8字节；

6. 应用场景:

   UDP:

   - 包总量较少的通信，如 `DNS` 、`SNMP` 等；
   - 视频、音频等多媒体通信；
   - 广播通信；

   TCP :

   ​	tcp应用在传输层有必要实现可靠传输的情况（HTTP / HTTPS请求），FTP文件传输；



##### 为什么TCP是安全可靠的？

因为`TCP`在

- 数据传输之前会有三次握手来进行连接
- 在数据传输时候，有确认、滑动窗口、超时重传、拥塞控制之类机制
- 数据传输之后会进行四次挥手断开连接来节约系统资源。

#### 1.1.5 websocket的实现和应用

1. 什么是websocket？

   websocket是一个**应用层协议**，依赖HTTP协议进行一次握手，握手成功后，数据直接从TCP通道传输，与HTTP无关了。

   客户端发送的消息：

   ```
   GET /chat HTTP/1.1
   Host: server.example.com
   Upgrade: websocket
   Connection: Upgrade
   Sec-WebSocket-Key: dGhlIHNhbXBsZSBub25jZQ==
   Origin: http://example.com
   Sec-WebSocket-Version: 13
   
   ```

   `Sec-WebSocket-Key` 是客户端随机生成的一个 base64 编码，服务器会使用这个编码;
   

websocket握手协议的实现，基本是2个属性，：
   `Upgrade: websocket`

   `Connection: Upgrade`

   服务器端返回消息

   ```undefined
   HTTP/1.1 101 Switching Protocols
   Upgrade: websocket
   Connection: Upgrade
   Sec-WebSocket-Accept: s3pPLMBiTxaQ9kYGzzhZRbK+xOo=
   ```

​		客户端拿到服务端响应的 Sec-WebSocket-Accept 后，会拿自己之前生成的 Sec-WebSocket-Key 用相同算法算一次，如果匹配，则握手成功

​	应用场景——**实时**

- 实时显示网站在线人数
- 账户余额等数据的实时更新
- 多玩家网络游戏
- 多媒体聊天，如聊天室

实例：一对一聊天

```js
function connectWebsocket() {
    ws = new WebSocket('ws://localhost:9000');
    // 监听连接成功
    ws.onopen = () => {
        console.log('连接服务端WebSocket成功');
        ws.send(JSON.stringify(msgData));    // send 方法给服务端发送消息 发送信息时只要通过send方法将输入框内容发送给后端就可以了
    };

    // 监听服务端消息(接收消息)
    ws.onmessage = (msg) => {
        let message = JSON.parse(msg.data);
        console.log('收到的消息：', message)
        elUl.innerHTML += `<li class="b">小秋：${message.content}</li>`;
    };

    // 监听连接失败
    ws.onerror = () => {
        console.log('连接失败，正在重连...');
        connectWebsocket();
    };

    // 监听连接关闭
    ws.onclose = () => {
        console.log('连接关闭');
    };
};
connectWebsocket();

```

解释：理解websocket的API，通过send()方法可以发送消息，onmessage事件用来接收消息，然后对消息进行处理显示在页面上，当onerror事件（监听连接失败）触发时，最好执行重连，保持连接不断

> 总结：当创建websocket实例的时候，会发送一个HTTP请求，请求的报文中有一个特殊字段**Upgrade**，然后这个连接会由HTTP协议转换为websocket协议，这样客户端和服务端建立了**全双工通信**，通过websocket的**send**方法和**onmessage**事件就可以通过这条通信连接交换信息。

*扩展：三种传输模式：*

- *单工通信：通信是单向的*（键盘和显示器）
- *半双工通信：通信是双向的，一次只允许一个发送一个接收，两个连接设备互换使用该通道*（对讲机）
- *全双工通信：通信是双向的，通道可以被链接的两个设备同时使用*（电话）

##### **心跳保活**

在实际使用Websocket中，长时间不通消息可能出现连接**不稳定**的情况，从而导致连接中断影响通信。

解决方法：**心跳保活**，客户端就像心跳一样每隔固定时间发送一次ping，来来告诉服务器我还活着，服务器也会返回pong 告诉客户端还活着，ping/pong 是一条与业务无关的假消息，称为**心跳包**

##### 如何监听用户离线？

当客户端第一次发送请求至服务端时会携带唯一标识、以及时间戳，服务端到db或者缓存（resdis）去查询改请求的唯一标识，如果不存在就存入db或者缓存中， 第二次客户端定时再次发送请求依旧携带唯一标识、以及时间戳，服务端到db或者缓存去查询改请求的唯一标识，如果存在就把上次的时间戳拿取出来，使用当前时间戳减去上次的时间， 得出的毫秒秒数判断是否大于指定的时间，若小于的话就是在线，否则就是离线；

##### 心跳检测

设置一个定时器，每30秒间隔发送一次心跳。

##### websocket兼容处理/降级方案 SEE

1.使用**轮询**或**长连接**的方式实现伪websocket通信

2.使用flash或其他方法实现一个websocket客户端

**问题背景：**

> 项目上前后端采用websocket通信，但是websocket连接经常会断开，虽然有重连机制，但是在重连的过程中，以及重连失败时，会影响前端数据的即时刷新。我们也不可能每次一出现问题就要求用户重启浏览器。因此需要设计一个websocket降级方案。

**降级思路：**

- 前端处理：当websocket断开或者超过一定时间没有收到消息时，将会自动切换为**轮询**，主动查询服务器最近是否有发送给前端的websocket消息。当websocket重连成功并收到消息后，取消轮询
- 后端处理：当后端发送websocket请求时，对发送的消息进行**缓存**，当前端进行查询时，返回发送给该前端的消息。同时将超过一定时长的消息(过期消息)，或者前端已查询过的消息(确保已经收到了)，从缓存中剔除，避免oom。

###### 扩展——轮询、长轮询

![1660043676358](assets/1660043676358.png)

![1660043709896](assets/1660043709896.png)

![1660043733166](assets/1660043733166.png)





##### websocket协议和http的差别?

websocket 是基于 http 协议的。借助 http 协议来完成握手。

连接之后客户端和服务器之间就可以随时通讯，直到其中一方关闭连接。

差别：

- websocket 是持久连接，http 是短连接；
- websocket 的协议是以 ws/wss 开头，http 对应的是 http/https；
- websocket 是有状态的，http 是无状态的；
- websocket 连接之后服务器和客户端可以双向发送数据，http 只能是客户端发起一次请求之后，服务器才能返回数据；
- websocket 是可以跨域的；
- websocket 连接建立之后，数据的传输使用**帧**来传递，不再需要Request消息。

#### 1.1.6 HTTP请求的方式

HTTP/1.1协议中共定义了**八种**方法（有时也叫“动作”），来表明Request-URL指定的资源不同的操作方式 

HTTP1.0定义了三种请求方法： GET, POST 和 HEAD方法。

HTTP1.1新增了五种请求方法：OPTIONS, PUT, DELETE, TRACE 和 CONNECT 方法

![](https://images2018.cnblogs.com/blog/1418466/201808/1418466-20180810112625596-2103906128.png)

##### get post请求的区别

- get 的含义是从服务器请求资源（只读操作)，post一般是提交数据，会修改服务器上资源

- get请求参数是通过URL传递的，post请求的参数是包含在请求体中的。
- get请求因为参数直接暴露在URL中，所以不能用来传递敏感信息
- get请求的参数会完整保留在浏览器的历史记录中，POST请求参数不会保留

##### HTTP常见的请求字段

> **http 请求字段**

`Accept` 接收类型，表示浏览器支持的MIME类型

`Content-Type`: 请求实体的内容的类型

`Cache-Control`：指定请求和响应的缓存机制 比如：no-cache（协商缓存验证）no-store(不使用任何缓存)、

`if-Modified-Since:` 对应服务器端请求响应的 Last-Modified,用来匹配文件是否变动

`Expries：` 缓存控制，在这个时间内不会请求，直接使用缓存，判断缓存是否过期会用到。

`Max-age: `代表资源在本地缓存多少秒，有效期内不会请求，直接使用缓存

`cookie：`设置了cookie时会自动带上（同源访问）

`Referer：`请求来源的URL

`Origin：`

`User-Agent：` 客户端的一些必要信息

> **响应头：**

`Access-Control—Allow-Orgin：` 允许请求的Origin头部

`Etag:` 特定版本资源的标识符，通常是消息摘要



#### 1.1.7  HTTP协议常见状态码20x/30X/400/500

详细：https://blog.csdn.net/piaoxuan1987/article/details/51603671

4XX 表示请求出错，妨碍了服务器处理

![image-20220209211233130](C:\Users\86153\AppData\Roaming\Typora\typora-user-images\image-20220209211233130.png)

![image-20220209211319250](C:\Users\86153\AppData\Roaming\Typora\typora-user-images\image-20220209211319250.png)

![image-20220417211313233](../../source/images/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95/image-20220417211313233.png)



<img src="../../source/images/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95/image-20220417211416809.png" alt="image-20220417211416809" style="zoom:50%;" />

1xx 含义：提示信息，表示目前是协议处理的中间状态，还需后续操作。

#### 1.1.8 fetch发送两次请求的原因

参考答案：

  fetch发送post请求的时候，总是发送2次，第一次状态码是204，第二次才成功？ 

  原因很简单，因为你用fetch的post请求的时候，导致fetch 第一次发送了一个Options请求，询问服务器是否支持修改的请求头，如果服务器支持，则在第二次中发送真正的请求。 





#### 1.1.9 怎样实现 一个图片URL访问后直接下载

https://blog.csdn.net/cheze3730/article/details/100596313



#### 1.1.10 说一下web Quality（无障碍）

能够被残障人士使用的网站才能称得上一个易用的（易访问的）网站。

Web Accessibility Initiative  - WAI

残障人士指的是那些带有残疾或者身体不健康的用户。 

- **使用可调节的字体大小**

​	请使用相对的字体尺寸，这样用户就能够使用浏览器菜单来改变默认的字体尺寸。

-   **使用alt属性：** 

  <img src="person.jpg"  alt="this is a person"/> 

  有时候浏览器会无法显示图像。具体的原因有： 

  用户关闭了图像显示 

  浏览器是不支持图形显示的迷你浏览器 

  浏览器是语音浏览器（供盲人和弱视人群使用）

 如果您使用了alt 属性，那么浏览器至少可以显示或读出有关图像的描述。 

#### 1.1.11 DOM 和 BOM

DOM —— 文档对象模型，是 HTML 和 XML 文档的编程接口（**API**），处理网页内容的方法和接口。document 是其的一个对象（对网页内容进行操作）

BOM —— 浏览器对象模型，和浏览器窗口交互的方法和接口,window 是其的一个对象。(对浏览器本身进项操作)

>  window 是 BOM 对象，而非 js 对象；

> javacsript是通过访问BOM（Browser Object Model）对象来访问、控制、修改客户端(浏览器)

二者详细区别：[https://blog.csdn.net/qq877507054/article/details/51395830](https://blog.csdn.net/qq877507054/article/details/51395830)



BOM中主要对象：

- window对象

- location对象：用于获取或设置窗体的URL，并且可以用于解析URL

  ![img](../../source/images/前端面试/BOM.png)

|   属性   |                  描述                   |
| :------: | :-------------------------------------: |
|   hash   |    设置或返回从井号(#)开始的URL(锚)     |
|   host   |    设置或返回主机名和当前URL的端口号    |
| hostname |        设置或返回当前URL的主机名        |
|   href   |           设置或返回完整的URL           |
| pathname |       设置或返回当前URL的路径部分       |
|   port   |        设置或返回当前URL的端口号        |
| protocol |         设置或返回当前URL的协议         |
|  search  | 设置或返回从问号(？)开始的URL(查询部分) |

- navigator对象：包含有关浏览器的信息，通常用于检测浏览器与操作系统的版本

|    属性     |                    描述                    |
| :---------: | :----------------------------------------: |
| appCodeName |          浏览器代码名的字符串表示          |
|   appName   |              返回浏览器的名称              |
| appVersion  |         返回浏览器的平台和版本信息         |
|  platform   |        返回运行浏览器的操作系统平台        |
|  userAgent  | 返回由客户端发送服务器的user-agent头部的值 |

- history对象：记录用户曾经浏览过的页面（URL），并可以实现浏览器前进与后退相似导航功能。

|  属性  |             描述              |
| :----: | :---------------------------: |
| length | 返回浏览器历史列表中的URL数量 |

|   方法    |               描述                |
| :-------: | :-------------------------------: |
|  back()   |   加载history列表中的前一个URL    |
| forward() |   加载history列表中的下一个URL    |
|   go()    | 加载history列表中的某个具体的页面 |







#### 1.1.12Cookie、sessionStorage、localStorage的区别

**共同点**：都是保存在浏览器端，且都是同源的

**存储大小限制**：

- cookie的数据大小不超过4K，

- sessionStorage和localStorage虽然也有存储大小的限制，但比	cookie大得多，可以达到5M或更大 	

**数据有效期限制:**

- cookie 在设置过期时间前有效，浏览器和窗口关闭不会影响
- sessionStorage：在当前窗口关闭前有效
- localStorage：始终有效，窗口或浏览器关闭也一直保存，因此用作持久数据

**作用域不同**

- sessionStorage：不在不同的浏览器窗口中共享，即使是同一个页面
- cookie 和 localStorage 在所有同源窗口中都是共享的

**Cookie：** cookie数据存放在浏览器中，在浏览器和服务器间来回传递，自动发送，数据始终在==同源的http==请求中携带 ，4kb大小限制

**sessionStorage和localStorage**：不会自动把数据发送给服务器，仅在本地保存。IE8以上的IE版本才支持localStorage这个属性

**web Storage：**支持事件通知机制，可以将数据更新的通知发送给监听者 。web Storage的api接口使用更方便 。



**应用场景**

- **Cookie**

  - 一般==用于与服务器交互的存储==，比如用户的登录信息，token令牌等。

  - 以便于下次登录时可以自动登录或记住密码

  - 保存上次登录的时间等信息

    保存上次浏览过的页面

    保存浏览次数

- **LocalStorage**常用于存储不易变动的数据，减轻服务器的压力

  - 缓存静态文件内容的JS，CSS
  - 缓存不常使用的==API接口数据==
  - 存储地理位置

- SessionStorage

  - 用于敏感账号的==一次性登录==，关闭当时页面再次打开页面时需要重新登录
  - 可以用来检测用户是否是刷新进入页面，如==音乐播放器恢复播放进度条的功能==。

##### **token**

是在客户端频繁向服务端请求数据，服务端频繁的去数据库查询用户名和密码并进行对比，判断用户名和密码正确与否，并作出相应提示，在这样的背景下，token 便应运而生。通常情况下**token**放在  cookie 里或者 localStorage 里 

##### token认证流程

1. 客户端使用用户名跟密码请求登录 
2. 服务端收到请求，去验证用户名与密码 
3. 验证成功后，服务端签发一个 token ，并把它发送给客户端 
4. 客户端接收 token 以后会把它存储起来，比如**放在  cookie 里或者 localStorage 里** 
5. 客户端每次发送请求时都在请求头里authorization字段中带着服务端签发的 token（把 token 放到 HTTP 的 Header 里） 
6. 服务端收到请求后，需要验证请求里带有的 token ，如验证成功则返回对应的数据 

##### cookie和session的共同点和区别

共同点：都是用来跟踪浏览器用户身份的会话方式

区别：

- cookie数据保存在浏览器，session数据保存在服务器
- cookie不是很安全，别人可以分析存放在本地的cookie并进行cookie欺骗，考虑安全性使用session
- session会在一定时间内保存在服务器上，当访问增多是会占用服务器性能，考虑性能使用cookie

##### 前端存几百M的数据——IndexDB

IndexedDB 是一种可以让你在用户的浏览器内持久化存储数据的方法， 允许储存大量数据，提供查找接口，还能建立索引。

#### *1.1.13 浏览器输入URL发生了什么？

[详细解释](https://www.jianshu.com/p/7eea6fbc5fcd)

**阶段一：发起URL请求**：

1.URL 解析 ，查找当前URL是否存在本地缓存资源，并比较缓存是否过期（强缓存、协商缓存），有就直接将缓存资源返回给浏览器进程，否则进入网络请求阶段。

2.DNS 解析 ，解析域名对应的IP和端口

- 首先搜索浏览器自己的DNS缓存（浏览器维护一张域名-IP地址的对应表），没有命中，下一步
- 搜索操作系统的DNS缓存，没有就下一步
- 搜索操作系统的hosts文件，没有就
- 操作系统将域名发送给本地域名服务器，之后如果仍未命中就像根域名服务器发送请求得到IP地址，然后将IP缓存起来

3.建立TCP连接 （三次握手，数据传输）

4.HTTP发送请求

5.服务器处理请求 

6.浏览器接受响应

7.渲染页面，构建DOM树

8.数据传输完毕后，关闭TCP连接（四次挥手）



问题1：DNS解析中端口需要DNS解析吗？

> 不需要，因为HTTP默认的是80端口，HTTPS默认的是443端口，如果要指定端口可以直接在URL里面添加。

问题2：哪些阶段可以优化？

> **请求阶段优化：**
>
> - 优化DNS查询：DNS预解析 （不需要用户点击链接就在后台解析，减少用户等待时间）
> - 优化TCP连接：建立长连接：请求设置keep-alive
> - 优化HTTP响应报文：通过CDN和Gzip压缩
> - 减少HTTP请求次数：精灵图、懒加载、缓存可缓存的资源
>
> **渲染优化：**
>
> - 减小文件体积：gzip压缩、使用缓存
> - 使用节流和防抖
> - 样式中避免使用通配符，通配符会遍历每个元素
> - 重绘和回流的优化

问题3：浏览器 DNS 缓存的时间一般不会太长，一分钟左右。为什么缓存不设置较长时间呢？

> 答：虽然 DNS 缓存可以提高获取 DNS 的速度，但缓存时间过长也会影响 DNS 在 IP **变更**时不能及时解析到**最新的 IP**。

问题4：输入URL后涉及到那些缓存

> 答：
>
> 1. 地址栏网址缓存
>
> 2. DNS缓存
> 3. ARP缓存（地址解析协议）
> 4. TCP发送和接收的缓冲区
> 5. HTTP请求缓存（CDN节点缓存，代理服务器缓存，浏览器缓存，后端动态缓存）

**阶段二：浏览器渲染阶段**



#### 1.1.14浏览器渲染原理（解析HTML过程）

[浏览器的渲染流程--重排、重绘、合成 - 简书 (jianshu.com)](https://www.jianshu.com/p/639aa67bd7ca)

1.解析HTML，构建**DOM树**

2.解析CSS，生成**CSS规则树**

3.合并DOM树CSS规则，生成**render树**（渲染树）

4.**布局**，根据render树计算每个节点的几何信息，生成**布局树**（Layout Tree）

5.**分层：**对布局树进行分层（页面的复杂效果如3D转换，z轴排列顺序等），并生成分层树（Layer Tree）

6.**绘制（Paint）：**为每个图层生成绘制列表，根据计算好的绘制列表信息绘制整个页面，并将其提交到**合成线程**。

8.**光栅化**：合成线程将图层分成图块（优先按照视口附近的），并在光栅化线程池中将图块转换成**位图**。

9.**合成（composite）：**合成线程发送绘制图块命令 DrawQuad 给浏览器进程，浏览器会将各层的信息发送给GPU，GPU会将各层**合成**，显示在屏幕上。

**注意：**

- 在浏览器还没接收到完整的HTML文件时，就已经开始渲染页面了，遇到外部链入的脚本标签或样式时，会再次发动HTTP请求重复上述步骤。

##### 重绘和重排

在这一过程中可能会触发页面的**重绘**或**重排**。这里就涉及了两个重要概念：Reflow和Repaint。

- 重排Reflow（也称作回流Layout布局 ），元素的尺寸、结构、位置发生变化、需要重新计算样式和渲染树。

  （例如：添加，删除可见的dom、页面渲染初始化、浏览器窗口大小变化，激活CSS伪类（例如：:hover））

  用户行为，如调整窗口大小、改变字号、滚动等

- 重绘Repaint ,元素的背景色、文字颜色、边框颜色发生改变

**重绘不一定需要重排（比如颜色的改变），重排必然导致重绘（比如改变网页位置）**

**如何避免重绘和重排（回流）**

- 浏览器自己优化：

​		浏览器会维护1个队列，把所有会引起重排，重绘的操作放入这个队列，等队列中的操作到一定数量或者到了一定时间间隔，浏览器就会flush队列，进行一批处理，这样多次重排，重绘变成一次重排重绘 	

- 减少reflow、repaint（减少DOM操作）
  
  - 为有动画效果的 元素的position使用 fixed 或 absoult 属性，脱离文档流，那么修改他们的 CSS 是不会 reflow 的。
  - 不要使用 table 布局。
  - 不要在布局信息改变的时候做查询（会导致渲染队列强制刷新）
  - 使用窗口resize尺寸变化时，做防抖和节流处理。
  
  **css优化**
  
  - 使用`visibility`替换`display:none`前者只会引起重绘，后者则会引发回流
  - 避免table布局 
  - 使用css3硬件加速，可以让`transform、opacity、filters`等动画效果不会引起回流重绘

js优化：

- 使用`display:none`的技术（只会引发两次回流和重绘）
  现将元素用display:none隐藏起来，接着对此元素进行所有的操作，最后再将此元素展示出来。**（PS：对display:none的元素进行操作是不会引起回流、重绘，故只要操作就只会有两次回流）**
- 不要一条一条地修改 元素的样式。一次性修改，可以先定义好 css 的 class，然后直接修改 元素的 className。 	
- 不要把 DOM 结点的属性值放在一个循环里当成循环里的变量。

##### 布局、绘制、合成

![1661827023727](assets/1661827023727.png)

合成是一种将页面的各个部分分离成层（Layer Tree），分别将它们栅格化，然后在称为“合成线程”的中组合为页面的技术。

**触发时机：**

在GUI渲染线程后执行，将GUI渲染线程生成的绘制列表转换为位图,然后发送绘制图块命令 DrawQuad 给浏览器进程，浏览器进程根据 DrawQuad 消息生成页面，将页面显示到显示器上



#### 1.1.15  浏览器强缓存和协商缓存

强缓存和协商缓存都是针对静态资源的，静态资源大，且短时间内不会更改，不需要再次请求，请求后直接保存在浏览器中，下次可以快速访问。

**当请求静态资源时，先去判断缓存是否过期：**

- 没过期就触发**强制缓存**，浏览器直接读取本地文件，HTTP状态码200；

- 文件已经过期了，触发**协商缓存**，发起请求询问服务器该文件是否有更新，没有更新就使用浏览器本都的缓存文件，文件有更新则服务器返回新的文件给客户端，且更新过期时间并缓存。



**浏览器如何知道一个资源是否过期？**

在请求的响应头中，有2个头部字段：expries、cache-control

- expries : 代表资源过期的绝对时间，http1.0
- cache-control: 代表相对时间，从客户端接收到资源那一刻起，经过多少时间才过期。http1.2

> 当 `expires`和 `cache-control`都存在， `cache-control`优先级高。

通过这两个字段就可以知道资源是否过期。



**如何判断一个资源是否更新？**

在请求的响应头（responseheader）中2个字段：`last-modify`最后更新时间、`Etag`文件标识

当下次发送同样的请求时，request的header会在两个字段`If-Modified-Since` `If-None-Match`带上`last-modify`和`Etag`对应的值;

服务器拿到这两个值结合自身实际情况判断，如果**没有变更**就告诉浏览器（**code 304**）,这个文件没有变化，可以继续使用，并且更新`expires`和`cache-control`，让这个文件再次缓存服务器设置的时间；

如果有变更，就把资源重新返回给客户端（code200），客户端重新缓存资源。

**总结：**

- 强制缓存和协商缓存都针对静态资源，动态资源实现缓存方法参考上方伪代码。
- 强制缓存在前，协商缓存在后。
- 资源未过期触发强制缓存，资源过期后再触发协商缓存。
- 判断过期的方法expires（绝对时间）、cache-control（相对时间）
- 判断资源是否有更新（Last-Modified 和 ETag）
- **强制缓存**在浏览器**强制刷新**的情况下不会生效， 而**协商缓存**则不受影响。

#### 1.1.16 Ajax 、axios 、fetch三种请求方式

##### Ajax

 Ajax是一种**异步请求数据**的web开发技术，对于改善用户的体验和页面性能很有帮助。

简单地说，在**不需要重新刷新页面**的情况下，Ajax 通过异步请求加载后台数据，并在网页上呈现出来。

常见**运用场景**有表单验证是否登入成功、百度搜索下拉框提示和快递单号查询等等。

 **ajax原理：** 

 	 Ajax的工作原理相当于在用户和服务器之间加了—个中间层(AJAX引擎),使用户操作与服务器响应异步化。并不是所有的用户请求都提交给服务器,像—些数据验证和数据处理等都交给Ajax引擎自己来做,   只有确定需要从服务器读取新数据时再由Ajax引擎代为向服务器提交请求。Ajax其核心有JavaScript、XMLHTTPRequest、DOM对象组成，通过XmlHttpRequest对象来向服务器发异步请求，从服务器获得数据，然后用JavaScript来操作DOM而更新页面 .

**创建ajax过程：**

1.  创建XMLHttpRequest对象,也就是创建一个异步调用对象. 	
2.  创建一个新的HTTP请求,并指定该HTTP请求的方法、URL及验证信息. 
3. 设置响应HTTP请求状态变化的函数. 	
4. 发送HTTP请求. 	
5.  获取异步调用返回的数据. 	
6.  使用JavaScript和DOM实现局部刷新. 	

**Ajax readyState的五种状态详解**

- 0：未初始化：确认XMLHttpRequest对象是否创建，值为0表示对象已经存在，此时还没有调用open
- 1：载入：对XMLHttpRequest对象进行初始化，开始向服务端发送请求，未调用send方法，还没发送请求
- 2：载入完成：接收服务端响应数据（原始数据）请求也发送完成
- 3：交互：解析响应的数据，部分数据可以获取
- 4：完成：解析完成，可以通过XMLHttpRequest对象的响应属性取得数据。

##### axios

axios本身是对ajax而言的一个二次封装，相比原生Ajax，它用到了promise技术，在成功之后可以用.then（）.catch（）进行链式调用。

- axios支持拦截请求和响应

- 客户端支持防御XSRF/CSRF(跨站请求伪造)

  如何支持的？

  > 就是让我们的每个请求都带一个从 cookie 中拿到的 key，根据浏览器同源策略，假冒的网站是拿不到你 cookie 中的 key 的，这样，后台就可以轻松辨别出这个请求是否是用户在假冒网站上的误导输入，从而采取正确的策略。

  1、从浏览器中创建 XMLHttpRequest

​        2、从 node.js 发出 http 请求

​        3、支持 Promise API

​        4、拦截请求和响应

​        5、转换请求和响应数据

​        6、自动转换JSON数据

​        7、客户端支持防止CSRF/XSRF

##### fetch

Fetch API 是近年来被提及将要取代`XHR`的技术新标准，是一个 HTML5 的 API。从一个全新的角度来思考的一种设计，是原生js，没有使用XMLHttpRequest对象。Fetch 是基于 Promise 语法结构。

**fetch的优点：**

1. 符合关注分离，没有将输入、输出和用事件来跟踪的状态混杂在一个对象里
2. 更好更方便的写法

**缺点：**

1、fetchtch只对网络请求报错，对400，500都当做成功的请求，需要封装去处理

2、fetch默认不会带cookie，需要添加配置项

3、fetch不支持abort，不支持超时控制，使用setTimeout及Promise.reject的实现的超时控制并不能阻止请求过程继续在后台运行，造成了量的浪费

4、fetch没有办法原生监测请求的进度，而XHR可以

5、fetch的返回值是一个promise对象

##### Ajax和axios的区别

- axios是基于promise的Http库，而ajax是对原生XHR的封装，axios实现了对ajax的封装
- axios支持拦截请求和响应，客户端支持防御XSRF

####  1.1.17 FTP DNS基于什么协议

 	DNS (Domain Name Service 域名服务) 协议基于 UDP协议 
 	
 	FTP (File Transfer Protocol 文件传输协议) 基于 TCP协议 
 	
 	DNS和FTP都是应用层协议 

#### 1.1.18 URL（统一资源定位符）路径包含什么

 	一个完整的url分为4部分： 

1.  **协议** 例 Http（超文本传输协议） 、Https、 	
2.  **域名**  例[www.baidu.com](https://link.jianshu.com?t=http://www.baidu.com)为网站名字。 [baidu.com](https://link.jianshu.com?t=http://baidu.com)为一级域名，www是服务 	
3.  **端口**  不填写的话默认走的是80端口号 	
4.  **路径** [http://www.baidu.com/](https://link.jianshu.com?t=http://www.baidu.com/)路径1/路径1.2。/表示根目录 	
5.  **查询参数** [http://www.baidu.com/](https://link.jianshu.com?t=http://www.baidu.com/)路径1/路径1.2?name="man"(可有可无) 	

#### 1.1.19 clientHeight, scrollHeight, offsetHeight ,以及scrollTop, offsetTop, clientTop的区别？

**clientHeight**：可视区域高度，不包含border和滚动条，通过浏览器看到的内容高度，==包含内边距+高度。==
**offsetHeight**： 可视区域高度，包含border和滚动条，==网页内容的实际高度，clientHeight+滚动条高度+边框 = offsetHeight；==
**scrollHeight**：所有区域高度，包含因滚动被隐藏的部分，网页内容的实际高度，
**clientTop**：**边框border的厚度**
**scrollTop**：滚动后被隐藏的高度，获取对象最顶端与窗口中可见内容最顶端之间的距离
**offsetTop**：获取指定对象相对于版面或布局中设置position属性的**父容器顶端位置的距离**

![img](../../source/images/前端面试/浏览器宽高.jpg)



#### 1.1.20 EventLoop 事件循环机制

**Js是单线程的，主线程执行时会不断从同步队列中读取任务执行。**

**同步队列执行完毕后再从异步队列中依次执行。**

**异步任务包括：宏任务和微任务。在执行上，微任务的优先级高于宏任务。**

主线程从”任务队列“中读取执行事件，这个过程是循环不断的，这个机制被称为事件循环；

主线程从任务队列中按顺序取任务执行，每执行完一个任务都会检查微任务队列是否为空，不为空则会一次性执行完所有微任务，然后在进入下一个循环去执行任务队列；

**循环过程执行步骤：**

 	1. 选择当前要执行的宏任务队列，选择一个最先进入任务队列的宏任务，一开始整个脚本作为一个宏任务执行，如果没有宏任务可以选择，则会 跳转至microtask的执行步骤。 
 	
 	2. 执行过程中同步代码直接执行，宏任务进入宏任务队列，微任务进入微任务队列。 
 	
 	3. 当前宏任务执行完出队，检查微任务列表，有则依次执行，直到全部执行完 
 	
 	4. 执行浏览器UI线程的渲染工作
 	
 	5. 检查是否有Web Worker任务，有则执行
 	
 	6. microtasks步骤：进入microtask检查点。 
 	
 	7. 执行完本轮的宏任务，回到2，依此循环，直到宏任务和微任务队列都为空




> 微任务包括：MutationObserver、Promise.then()或catch()、Promise为基础开发的其它技术，比如fetch API、V8的垃圾回收过程、Node独有的process.nextTick。
>
> 宏任务包括：script 、setTimeout、setInterval 、setImmediate 、I/O 、UI rendering。
>
> 注意⚠️：在所有任务开始的时候，由于宏任务中包括了script，所以浏览器会先执行一个宏任务，在这个过程中你看到的延迟任务(例如setTimeout)将被放到下一轮宏任务中来执行。





#### 1.1.21浏览器的垃圾回收机制

**垃圾收集器会定期（周期性）找出那些不在继续使用的变量，然后释放其内存**

不再使用的变量也就是生命周期结束的变量，当然只可能是局部变量，全局变量的生命周期直至浏览器卸载页面才会结束。局部变量只在函数的执行过程中存在，而在这个过程中会为局部变量在栈或堆上分配相应的空间，以存储它们的值，然后在函数中使用这些变量，直至函数结束，而闭包中由于内部函数的原因，外部函数并不能算是结束。

标记的无用变量的策略：**标记清除**和**引用计数**

- **标记清除的原理**：垃圾回收器在运行的时候会给存储在内存中的所有变量都加上标记，但是会去掉进入环境中的变量以及被环境中的变量引用的变量的标记（闭包），

  在此之后再被加上标记的变量将被视为准备删除的变量

  然后垃圾回收器完成内存清除工作，销毁那些带标记的值并回收它们所占用的内存空间。
  
  ##### 什么时候触发垃圾回收
  
  - 周期性运行，固定时间间隔
  - 根据内存的分配量，垃圾回收器回收的内存分配量低于程序占用内存的15%，说明大部分内存不可被回收。高于85%，说明大部分内存早就该清理了。动态修改触发条件

- 引用计数：将对象是否不再需要简化定义为有没有其他对象引用它，如果没有引用指向这个对象，则会被垃圾回收机制回收。（内存空间不连续）

#### 1.1.22 connection：keep-alive

如果开启 keep-alive，则服务端在返回 response 后不关闭 TCP 连接；同样的，在接收完响应报文后，客户端也不关闭连接，发送下一个 HTTP 请求时会重用该连接。

#### 1.1.23 同步请求和异步请求的区别

- 异步：发送方发出数据后，不等接收方发回响应，接着发送下个数据包的通讯方式。简单来讲：各走走的，不用等待上一个请求
-  同步：发送方发出数据后，等接收方发回响应以后才发下一个数据包的通讯方式。







#### 调试工具

1.谷歌浏览器自带的调试工具

2.postman 接口调试工具

2.**CSS Lint**

### 1.2 HTML

#### 1.2.1 HTML标签的作用

`!DOCTYPE`

指示浏览器关于页面使用哪个版本的HTML进行编写的指令

`head`

所有头部元素的容器，绝大多数的头部标签内容不会显示给读者

 `body : `

- 用于定义文档的主体, 包含了文档的所有内容 	
- 该标签支持 html 的全局属性和事件属性. 	

#### 1.2.2  h5新特性

**总结：**

1. 用于绘画的canvas元素
2. 新增选择器 document.querySelector、document.querySelectorAll 
3. 更加丰富强大的表单 ：增强表单控件 calendar、date、time、email、url、search 
4. 用于媒介的video和audio元素
5. html5地理定位 Geolocation
6. 历史管理 history
7. html5拖拽释放 drag and drop
8. web存储
9. 应用程序缓存 localstorage、sessionstorage
10. websocket
11. 服务器发送事件
12. WebWorkers 多任务

**HTML5中的语义化标签**

1. article、footer、header、nav、section、time、mark、figure、aside

​	**语义化优点：**

- 易于用户阅读，样式丢失的时候能让页面呈现清晰的结构。 
- 有利于SEO，搜索引擎根据标签来确定上下文和各个关键字的权重。 
- 方便屏幕阅读器解析，如盲人阅读器根据语义渲染网页 
- 有利于开发和维护，语义化更具可读性，代码更好维护，与CSS3关系更和谐。 

**废除的元素**

大部分能用css代替的标签都废除

- 纯表现元素：basefont、big、center、s、strike、tt、u、dir、font
- 对可用性产生负面影响的元素：frame、frameset、noframes



#### 1.2.4 iframe元素 有什么优缺点

iframe 元素会创建包含另外一个文档的内联框架（即行内框架）

优点： 

1. iframe能够吧嵌入的网页原样显示出来
2. 模块分离，便于更改
3. 增加代码的可重用（网页如果为了统一风格，头部和版本都是一样的，就可以写成一个页面，用iframe来嵌套）
4. 方便制作导航栏、广告等

缺点：

1. 在移动设备可能无法完全显示框架，设备兼容性差
2. 样式和脚本需要额外链入，增加服务器的HTTP请求
3. 代码复杂



**为什需要尽量少用iframe**

*iframe会阻塞主页面的Onload事件及iframe和主页面共享连接池，会影响页面的并行加载。*

1. iframe阻塞页面加载，影响网页加载速度
2. iframe和主页面共享连接池，而浏览器对相同域的连接有限制，所以会影响页面的并行加载。会产生很多页面，不容易管理。

​		解决办法是让优先级更高的资源下载完成后再动态的给iframe的src赋值。

 **iframe的应用场景**

- 加载广告
- 网页编辑器
- 一般邮箱使用iframe、如QQ邮箱
- 一些简单的后台页面
- 跨域通信。JavaScript跨域总结与解决办法 ，类似的还有浏览器多页面通信，比如音乐播放器，用户如果打开了多个tab页，应该只有一个在播放；



#### 1.2.5 什么是XML？

- XML 指可扩展标记语言（**EXtensible Markup Language**） 
- XML 是一种标记语言，很类似 HTML 
-  XML 的设计宗旨是传输数据，而非显示数据 
-  XML 标签没有被预定义。您需要自行定义标签。  XML 被设计为具有自我描述性。 
-  XML 是 W3C 的推荐标准   

#### 1.2.6 XML与HTML的差异：

> ​    XML 不是 HTML 的替代。   
>
> ​    XML 和 HTML 为不同的目的而设计：   
>
> ​    **XML 被设计为传输和存储数据，其焦点是数据的内容。**   
>
> ​    HTML 被设计用来显示数据，其焦点是数据的外观。   
>
> ​    **HTML 旨在显示信息，而 XML 旨在传输信息。**   

### 1.3 js基础

#### 1.3.1 let const var 

**var**——**es5**变量声明方式，变量未赋值时为undefined；

作用域：方法作用域

特点：

- 变量声明提升 （赋值不会提升）
- 变量覆盖（可以重复声明变量）
- 没有块级作用域

**const、let**——**es6**变量声明方式

1. let在变量未声明前直接使用会报错 ，var在变量未赋值时，变量undefined

2. 作用域——**let**为**块作用域**——通常let比var 范围要小 ,

   作用域——**var的作用域为方法作用域**；只要在方法内定义了，整个方法内的定义变量后的代码都可以使用 

3. let禁止重复声明变量，否则会报错；var可以重复声明 

4. const为常量声明方式；**声明变量时必须初始化**，在后面出现的代码中**不能再修改**该常量的值，支持let的其他属性（块级作用域）

#### 1.3.2 js的数据类型

一共八种，分为2类

基本数据类型：——存储在栈中

`Number、String、Boolean、null、undefined、symbol、bigint`

（**Symbol**是ES6新出的一种数据类型，这种数据类型的特点就是没有重复的数据，可以作为object的key。

   **BigInt**也是ES6新出的一种数据类型，这种数据类型的特点就是数据涵盖的范围大，能够解决超出普通数据类型范围报错的问题。）

引用数据类型：——存储在堆中，引用数据类型是同时存放于栈和堆中，在堆中存对象值，栈中存对象指针，指向堆中该实体的起始地址。

`object（普通对象，数组，正则，日期，Math数学函数都属于Object。）`





两种数据**类型存储**的区别：

1. 堆比栈空间大，栈比堆运行速度快。 	
2. 堆内存是无序存储，可以根据引用直接获取。 	
3. 基础数据类型比较稳定，而且相对来说占用的内存小。 	
4. 引用数据类型大小是动态的，而且是无限的。 	

**两种数据类型的区别：**

1、存储方式的区别（见上）

2、比较上的区别，基本数据类型比较时是值的比较；引用数据类型比较时是引用的比较，比较的是地址，也就是比较两个对象保存在栈区的指向堆内存的地址是否相同。

```js
var a = {}
var b = {}
console.log(a == b) //false
```

3、赋值的区别：

- 基本类型数据赋值，就是简单的赋值，相当于就会在变量对象上创建一个新值，然后把这个值复制到为变量新分配的位置上
- 引用类型赋值是对象的引用，也就是浅拷贝，只赋值地址，两个地址指向同一个对象，共享同一块内存，改变其中任何一个变量都会互相影响。





#### 1.3.3 constructor的理解 ？

创建每个函数都有一个prototype(原型)对象

这个属性是一个指针，指向一个对象。在默认情况下，所有原型对象都会自动获得一个constructor（构造函数）属性，这个属性是一个指向prototype属性所在函数的指针。

#### 1.3.4 map遍历 和forEach 的区别

相同点：

1. 都是循环遍历
2. 每次执行匿名函数都支持三个参数，参数分别为item（当前的项），index（索引），arr（原数组）
3. 匿名函数中的this 都是指向window
4. 只能遍历数组

不同点：

1.map()会分配内存空间存储新数组并返回，forEach()不会返回数据。

2.forEach()允许callback更改原始数组的元素，map()返回新的数组。

#### 1.3.5 遍历对象的方法

1. for...in，可以得到**对象原型链**上的属性(可枚举)

   > 对象的属性有可枚举和不可枚举之分，它是由对象属性描述符`enumerable`决定的。

   > - 通过`Object.defineProperty()`定义的属性，enumerable（是否可枚举），configurable（是否可删除可改变），writable(是否可被赋值运算符改变)这几个值默认为false
   > - 直接为对象动态添加属性，enumerable，configurable，writable这几个值默认为true

   ```js
   const obj = Object.create({
    bar: 'bar'
   })
   obj.foo = 'foo'
   for (let key in obj) {
    console.log(obj[key]) // foo, bar
   }
   //对象原型上的属性也被循环出来了
   ```

   可以使用对象的`hasOwnProperty()`方法**过滤原型链上的属性**

   ```js
   for(let key in obj){
   	if(obj.hasOwnProperty(key)){
   		console.log(obj[key]);//foo
   	}
   }
   ```

2. `Object.keys()` ，该方法可以返回对象自身**属性**组成的数组，并且会自动过滤掉原型链上的属性，通过`forEach()`可以遍历 

   ```js
   Object.keys(obj).forEach((key)=>{
       console.log(obj[key]);//foo
   })
   ```

   另外还有：

   - **`Object.values`**: 返回由**属性值**组成的数组

   - **`Object.entries()`**：返回由自身可枚举属性的**键值对**组成的数组 `[[key,value],[key,value]]`

    Object.keys()、Object.values()、Object.entries() 返回的都是自身可枚举的属性。

   **tips**: 将Object转换为Map,利用Object.entries()

   ```js
   var obj = { foo: "bar", baz: 42 }; 
   var map = new Map(Object.entries(obj));
   console.log(map); // Map { foo: "bar", baz: 42 }
   ```

   for in 循环和 Object.keys() 方法都**不会**返回对象的**不可枚举**属性

3. `Object.getOwnPropertyNames`

   该方法返回对象自身**属性名**组成的数组，**包括不可枚举的属性**，也可以通过数组的 `forEach `方法来遍历.

   ```js
   // 创建一个对象并指定其原型，bar 为原型上的属性
   // baz 为对象自身的属性并且不可枚举
   const obj = Object.create({
    bar: 'bar'
   }, {
    baz: {
     value: 'baz',
     enumerable: false
    }
   })
    
   obj.foo = 'foo'
   
   Object.getOwnPropertyNames(obj).forEach((key) => { console.log(obj[key]) // baz, foo 
         })
   
   ```

   **Object.getOwnPropertySymbols() **：返回对象自身的 **Symbol 属性**组成的数组，不包括字符串属性

4.  `Reflect.ownKeys()`

   该方法返回对象自身所有属性名组成的数组，包括不可枚举的属性和 Symbol 属性

   ```js
   // 给对象添加一个不可枚举的 Symbol 属性
   Object.defineProperties(obj, {  [Symbol('baz')]: {   value: 'Symbol baz',   enumerable: false  } })
   
   // 给对象添加一个可枚举的 Symbol 属性
   obj[Symbol('foo')] = 'Symbol foo'
   
   Reflect.ownKeys(obj).forEach((key) => {
    console.log(obj[key]) // baz, foo, Symbol baz, Symbol foo
   })
   ```

![1661739659492](assets/1661739659492.png)

##### for...of...可以遍历哪些对象

es6新增的遍历方法，只用于**迭代器**（iterator）

可迭代的对象：Array、Map、Set、String、TypeArray、arguments对象等。

##### for …in 和for.. of的区别

1. for...in 循环：只能获得对象的键名（数组的索引），不能获得键值

    for...of 循环：允许遍历获得**键值**

2. for of 只能遍历可迭代的对象

3. for...in，可以得到**对象原型链**上的属性(可枚举)

4. forEach 循环无法中途跳出，break 命令或 return 命令都不能奏效

5. `for in`更适合遍历对象，当然也可以遍历数组，但是可能会出现问题，比如`index`索引为字符串型数字，不能直接进行几何运算

   `for of`适用遍历数/数组对象/字符串/`map`/`set`等拥有迭代器对象（`iterator`）的集合，但是不能遍历对象，因为没有迭代器对象，但如果想遍历对象的属性。

   

#### 1.3.5 js静态类型检查

js是动态类型语言

静态类型语言&动态类型语言

**静态类型语言**：类型检查发生在编译阶段，因此除非修复错误，否则会一直编译失败。

**动态类型语言**：只有在程序运行一次后才会发现错误，编译时检查出不来

**js静态类型检查的方法：**

- Facebook开发的**Flow**工具：开源的静态类型检查库，它允许你逐渐向JavaScript代码中添加类型。
  - Flow工作原理：在代码当中通过添加一些类型注解的方式，来去标记我们代码当中每个参数，每个变量，它是什么类型的，然后Flow根据这些类型注解就可以检查代码当中是否会存在类型使用的异常，从而去实现我们在开发阶段对类型异常的一个检查，这就避免了我们在运行阶段去发现类型的错误。

- **Typescript**是一个会编译为JavaScript的超集。

**Flow VS. TypeScript**

`Flow`与`TypeScript`都是静态类型检查器，`TypeScript`的功能更加强大，但他们都是`JavaScript`的超集，基于`JavaScript`，最终都要编译成`JS`运行。一般大型项目都需要静态类型检查来确保代码的可维护性和可读性，`Vue2.0`的源码引入了`flow`，`flow`可以让代码在最小改动的情况下使用动态类型检查，而在`Vue3.0`中已经使用`TypeScript`开发了。



使用静态类型的优势：

1. 可以尽早发现bug和错误
2. 减少单元测试数量
3. 减少了复杂的错误处理

劣势：

1. 代码冗长

#### 1.3.6 str.indexOf(searchValue [, fromIndex])

- 查找的字符串searchValue的**第一次**出现的索引，如果没有找到，则返回-1。

- 在使用indexOf检索数组时，用‘===’去匹配，意味着会检查数据类型

#### 1.3.7 变量提升和函数提升

- 详细说明：[https://zhuanlan.zhihu.com/p/100563316](https://zhuanlan.zhihu.com/p/100563316)

JavaScript是单线程语言，执行时按顺序执行。一段一段的分析执行

在**编译**的过程中，先将**标识符**和**函数声明**给**提升到其对应的作用域的顶端**。标识符解析的时候，会进行LHS查询，在LHS查询的时候，如果标识符一直找不到声明的位置，那么最终就会在全局环境生成一个全局变量。 所以能在真正被声明之前使用。

（LHS ： 指的是赋值操作的左端。）

（RHS指的是赋值操作的源头。RHS查询的时候，如果找不到对应的标识符，就会抛出一个异常：ReferenceError。）

变量提升的**前提**是使用**var关键字**进行声明的变量；变量提升的是==变量声明==，但==赋值不会提升==

**使用let和const声明的变量不会提升**，并且会形成暂时性死区，就是在该作用域当中，无法在变量声明前访问，即使全局存在一个同名变量，也无法访问

函数声明提升会比变量提升**优先**；

**函数提升，只会提升函数声明，而不会提升函数表达式。**



当函数声明与变量声明重复时

a.如果变量有值，那么输出的就是变量的值。
b.如果变量没有值，那么输出的就是这个函数。

```js
f();
fn();//fn is not a function 

//函数表达式
var fn = function(){
    console.log(1)
}

//函数声明
function f(){
    console.log(0)
}

```

补充：如果在函数声明时带有*****号，函数会成为一个生成器函数，调用生成器函数会返回生成器（Generator）对象，例：

执行gen()，执行后返回一个Generator对象,而不是undefined

```js
function * gen() {
    yield 1;
    yield 2;
    yield 3;
}
```



#### 1.3.8 作用域

作用域的用处就是隔离变量，不同作用域下的同名变量不会有冲突

es6提供块级作用域：`let和const`,es6之前只有函数作用和全局作用域



#### 1.3.9 HashMap 和Array有什么区别

1. 查找效率

- hashmap根据hashcode值算出index的值，查找效率随数组长度增大而增加。
- arraymap 使用二分查找，数组长度每增加一倍就需要多进行一次判断

2. 扩容数量

- HashMap初始值16个长度，每次扩容的时候，直接申请双倍的数组空间。

- 如果数据量比较大的时候，还是使用HashMap更合适，因为其扩容的次数要比ArrayMap少很多。 	

3. 扩容效率

- HashMap每次扩容的时候重新计算每个数组成员的位置，然后放到新的位置。
-  ArrayMap则是直接使用System.arraycopy，所以效率上肯定是ArrayMap更占优势。 	

**总结：**

数据量比较小，并且需要频繁的使用Map存储数据的时候，推荐使用ArrayMap。 

而数据量比较大时候，则推荐使用HashMap。

#### 1.3.9.1Map和Object的区别

Object和map都是key-value 键值对的形式存值；

**主要的区别是**：

- 一个**Map**的**键**可以时**任意值**，包括函数、对象或任意基本类型。一个**Object**的键必须是一个**String**或**Symbol**类型。
- 键的顺序：Map中的key是有序的，因此，当迭代的时候，一个Map对象是以插入的顺序返回键值；一个Object的键是无序的；
- size：Map的键值对个数可以通过size属性获取，而object的键值对个数只能通过手动计算？
- 迭代：Map是iterable的，可以被迭代，而object需要先获取键然后才能迭代。
- 性能：Map适合频繁增删键值对的场景。

##### Map和set的区别

- Set 的成员值是唯一的，set构造函数可以接受一个数组当参数，用来初始化。初始化需要的是一维数组；Map需要的是一个二维数组；

- Map是键值对的存在，而Set没有value只有Key，value就是key；

##### Map和weakmap的区别

1. *WeakMap只接受**对象**作为key，如果设置其他类型的数据作为key，会报错。*
2. *WeakMap的key所引用的对象都是弱引用，只要对象的其他引用被删除，垃圾回收机制就会释放该对象占用的内存，从而避免内存泄漏。*
3. *由于WeakMap的成员随时可能被垃圾回收机制回收，成员的数量不稳定，所以没有size属性。*
4. *没有clear()方法*
5. 不能遍历
6. 当键的外部引用删除时，希望自动删除数据时使用 WeakMap

##### 介绍一下 set weakSet、map weakMap

 	**Set** 

1.  成员不能重复； 	
2.  只有键值，没有键名，有点类似数组； 	
3.  可以遍历，方法有add、delete、has 	

 	**WeakSet** 

1. 成员都是**对象**（引用）； 	
2.  成员都是弱引用，随时可以消失（不计入垃圾回收机制）。可以用来保存 DOM 节点，不容易造成内存泄露； 	
3.  **不能遍历**，方法有add、delete、has； 	

 	**Map** 

1.  本质上是键值对的集合，类似集合； 	
2.  可以遍历，方法很多，可以跟各种数据格式转换； 	

 	**WeakMap** 

1. 只接收对象为键名（null 除外），不接受其他类型的值作为键名；	

2.  键名指向的对象，不计入垃圾回收机制； 	
3. **不能遍历**，方法同get、set、has、delete； 	

#### 1.3.10 JavaScript中argument相关问题

arguments

在js中，调用有参数的函数时，会向函数传参，js会吧所传的参数全部存到一个叫arguments的对象里面，它是一个类数组数据。

作用：
有了arguments这个对象之后，可以不用给函数预先设定形参，可以动态的通过arguments为函数加入参数。



#### 1.3.11 instanceOf 原理，动手实现function

instanceOf主要作用就是判断一个实例是否属于某种类型，原理是基于原型链的查询，只要处于原型链中，判断永远为true。

```js
function myinstance(left,right){
    if(typeof left !== "object" || left === null) return false;
    let proto = Object.getPrototypeOf(left);
    while(true){
        if(proto==right.prototype) return true;
        if(proto==null) return false;
        proto = Object.getPrototypeOf(proto);
    }
}
```



#### 1.3.12 说一说对闭包的理解

闭包形成的**原理**：通常是在嵌套函数中实现的，内层函数引用了外层函数的变量，当外层函数执行完毕时，这个变量也不会被销毁，从而就可以**利用**闭包突破作用域链，将这个内部函数的变量和方法传递出去。

闭包带来的**问题**：内存泄露，内存泄露积累多了就容易导致内存溢出。

闭包形成的**条件**：

1.函数嵌套

2.将内部函数作为返回值返回

3.内部函数必须使用到外部的变量

闭包场景：

在**定时器**、事件监听、Ajax请求、跨窗口通信、Web Workers或者任何异步中，只要使用了**回调函数**，实际上就是在使用闭包。

#### 1.3.13 promise

es6中promise是**异步编程**的一种方案，从语法上讲，**Promise是一个对象**，它可以获取异步操作的消息，将异步操作以同步的流程表达出来。

好处：

- 可以很好的解决**回调地狱**的问题（避免了层层嵌套回调函数）
- 语法简洁，使得控制异步操作更简便

**Promise的使用**：

```js
var promise =  new promise((resolve,reject)=>{/* executor函数 */
    if(/*异步操作成功*/){
       resolve(value);
       }else{
               reject(error)
                           
       }
});
promise.then((value)=>{
    //success
    
}，(error)=>{
    //failure
})
/*
参数说明
executor函数在Promise构造函数执行时同步执行，被传递resolve和reject函数（executor函数在Promise构造函数返回新建对象前被调用）。
executor内部通常会执行一些异步操作，一旦完成，可以调用resolve函数来将promise状态改成fulfilled(完成)，或者将promise的状态改为rejected(失败)。
如果在executor函数中抛出一个错误，那么该promise状态为rejected。executor函数的返回值被忽略。 

*/

```

使用：

```js
function timeout(ms) {
    return new Promise((resolve, reject) => {
        setTimeout(resolve, ms, 'done');
    });
}

timeout(2000).then((value) => {
    console.log(value); //done
});
```

#### 1.3.14 NaN是什么 ?NaN == NaN 的结果是什么?为什么?

`NaN：not a number,`表示存储的数据的数据类型，不是一个数值。 如果有非数值参与非加法计算,结果就是 NaN。

- 当两个变量中存储的数据都不是数值时，执行结果就是NaN。

```js
var str1 = 'abc'
var str2 = 'def'
var res = str1-str2
console.log(res)//NaN
```

- 有NaN(非数字)参与非加法运算 ,结果就是NaN
- 如果是 + 加号，两侧都是数值,执行加法运算， 有一个是[字符串](https://so.csdn.net/so/search?q=字符串&spm=1001.2101.3001.7020)，就执行字符串拼接操作。

```js
var str1 = 'abc'
var str2 = 100
var res = str1+str2
console.log(res)//abc100
```

NaN == NaN 执行结果是 false。JavaScript的规定，NaN表示的是非数字， 但是这个非数字也是不同的，因此，NaN 不等于 NaN，并且**两个NaN永远不可能相等**。

#### *1.3.15 跨域？如何解决跨域

**跨域：**只允许浏览器请求同一域名下的服务，当前页面中某个接口的请求地址和当前页面的的地址在 **协议**、**域名**、**端口**其中有一项不同，就说明该接口跨域了。

跨域限制的**原因**：浏览器为了保证网页的安全，出于**同源协议策略。**

**同源策略：**一种为浏览器安全考虑而出台的一种策略，它可以保证用户信息安全，防止恶意的网站窃取。

**解决方案：** （配置后端、配置前端、配置服务器）

- 1、cors（跨域资源共享）： 通过设置**后端**允许跨域实现

```
res.setHeader('Access-Control-Allow-Origin', '*');
res.setHeader("Access-Control-Allow-Methods", "GET, PUT, OPTIONS, POST");
```

请求可以分为简单请求（方法为get/post/head和一些其他的规定）和复杂请求，当请求为复杂请求时会触发预检请求。

##### 预检请求：

使用Options方法发起一个预检请求到服务器，以获知服务器是否允许该实际请求，服务器确认后才发起实际的HTTP请求，可以避免跨域请求对服务器的用户数据产生未预期的影响。

关键字段 ：
`Access-Control-Request-Method `：告知服务器，实际请求将使用 的方法
`Access-Control-Request-Headers`：告知服务器，实际请求将携带的自定义请求首部字段



当触发预检时，跨域请求便会发送2次请求，既增加了请求数，也延迟了请求真正发起的时间，影响性能；

**减少OPTIONS请求次数 ：**
**OPTIONS**请求 次数过多机会损耗页面加载的性能，降低用户体验度。所以尽量要减少OPTIONS请求次数，可以后端在请求的返回头部添加：**Access-Control-Max-Age: number**。它表示预检请求的返回结果可以被缓存多久，单位是秒。这字段值对完全一样的URL的缓存设置生效，所以设置了缓存时间，在这个时间范围内，再次发送请求就不需要进行预检请求了。

- 2、**配置代理**：node中间件和nginx反向代理，都是**让请求发给代理服务器**，静态页面和代理服务器是同源的，然后代理服务器再向后端服务器发请求，服务器和服务器之间不存在同源限制。

##### 正向代理和反向代理的区别

在正向代理中，`proxy`是`client`设置的，用来隐藏`client`；而在反向代理中，`proxy`是`server`设置的，用来隐藏`server`.

`NginX`是一款`轻量级的Web服务器`，也可以用于`反向代理`，`负载均衡`和`HTTP缓存`等。

- 3、JSONP：利用的原理是通过src或者href请求的js脚本，css文件等文件不存在跨域问题，而只有ajax请求服务才会存在跨域问题，通过带有`参数`和`回调函数`的`url`发起一次get请求（这也是jsonp只能发起get请求的原因，因为只有get请求才能把参数和回调函数拼接到url中），`服务器将接口返回的数据拼凑到回调函数中`，返回给浏览器，浏览器解析执行，从而前端`拿到回调函数返回的数据`。

jsonp基于这个原理实现解决跨域。不过现在很少用，原因是

1.不适合react、vue等框架的开发

2.并且也有安全隐患

```html
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Title</title>

</head>
<body>
//在script标签的src属性后面，拼接上一个 callback=回调函数名
<script src="http://www.example.com:5000/data.js?callback=showDate"></script>
<script>
	//会在跨域请求后，调用该函数
    function showDate(data) {
        console.log(data)
    }
</script>
</body>
</html>


```



- postmessage：H5新增API，通过发送和接收API实现跨域通信。

  发送端：两个参数：message: 要发送到另一个窗口的数据（字符串或对象）、targetOrgin：要发送消息的URL。
  
  接收端：用`addEventListener`
  
  event对象有三个属性，分别是origin，data和source。event.data表示接收到的消息；event.origin表示postMessage的发送来源，包括协议，域名和端口；event.source表示发送消息的窗口对象的引用; 
  
  ```js
  window.addEventListener("message", receiveMessage, false);
  function receiveMessage(event){
    if (event.origin !== "http://www.42du.cn")
      return;
  }
  ```
  
  例子：
  
  (A页面中包含一个iframe,iframe加载B页面(子窗体与父窗体通信))
  
  ```js
  A页面代码:
  window.addEventListener('message', function(e) {
  　　if (e.data.test=="Test") {
  　　　　alert(e.data.test);
  　　}
  }, false);
   
  B页面代码:   btnClick: function () {
  　　window.parent.postMessage({ test: "Test"}, "*"); 
  　　//{ test: "Test" }为data属性,"*" 为origin属性 
  }
  
  ```
  
  ```js
  父子窗口通信
  A页面代码: 
  function btnClick() {
  document.getElementById("iframeContent").contentWindow.postMessage({ test: "Test"});
  };
  B页面代码: （接收端）
   window.addEventListener('message', function(e) {
  　　if (e.data.test=="Test") {
  　　　　alert(e.data.test);
  　　}
  }, false);
  ```
  
  
  
  **跨域场景**：前后端分离式开发、调用第三方接口

#### *1.3.16 js中判断变量类型的方法有哪些

有5种：

- **typeof**：判断基本数据类型，对于引用数据类型，除**function**外均返回Object
- instanceof：区分引用数据类型。对于undefined、null、symbol检测不出来。
- **Object.prototype.toString.call()**对象原型链判断方法：适用于**所有类型检测且检测最精准**，返回该类型的的字符串
- constructor（用于引用数据类型）：用于检测引用数据类型
- **jquery.type()** --万能

例：

```js
var a = "iamstring.";
var b = 222;
var c= [1,2,3];
var d = new Date();
var e = function(){alert(111);};
var f = function(){this.name="22";};　

//typeof
alert(typeof a)  //------------> string
alert(typeof b)  //------------> number
alert(typeof c)  //------------> object
alert(typeof d)  //------------> object
alert(typeof e)  //------------> function
alert(typeof f)  //------------> function

//instanceof 后面一定要是对象类型，并且大小写不能错，该方法适合一些条件选择或分支。　　 
alert(c instanceof Array) //---------------> true
alert(d instanceof Date)
alert(f instanceof Function) //------------> true
alert(f instanceof function) //------------> false

//constructor 
alert(c.constructor === Array) //----------> true
alert(d.constructor === Date) //-----------> true
alert(e.constructor === Function) //-------> true
//(constructor 在类继承时会出错)
function A(){};
function B(){};
A.prototype = new B(); //A继承自B
var aObj = new A();
alert(aobj.constructor === B) -----------> true;
alert(aobj.constructor === A) -----------> false;
//用instance 不会出错
alert(aobj instanceof B) ----------------> true;
alert(aobj instanceof B) ----------------> true;

//prototype
alert(Object.prototype.toString.call(a) === '[object String]') //-------> true;
alert(Object.prototype.toString.call(b) === '[object Number]')// -------> true;
alert(Object.prototype.toString.call(c) === '[object Array]') //-------> true;
alert(Object.prototype.toString.call(d) === '[object Date]') //-------> true;
alert(Object.prototype.toString.call(e) === '[object Function]') //-------> true;
alert(Object.prototype.toString.call(f) === '[object Function]') //-------> true;

//jQuery.type
jQuery.type( true ) === "boolean"
jQuery.type( 3 ) === "number"
jQuery.type( "test" ) === "string"
jQuery.type( function(){} ) === "function"
jQuery.type( [] ) === "array"
jQuery.type( new Date() ) === "date"
jQuery.type( new Error() ) === "error" // as of jQuery 1.9
jQuery.type( /test/ ) === "regexp"
```



#### 1.3.17 数组去重的方法

- 在ES6中可以用set去重 ，new 一个 Set，参数为需要去重的数组，Set 会自动删除重复的元素，再将 Set 转为数组返回。

  `[...new Set(arr)]`

- 开辟新数组，遍历原数组，对不重复的数进行保存 ，用`newarr.indexOf(item)===-1`  或`!newarr.includes(item)`

##### 数组和伪数组的区别

- 数组与常规对象的区别是：有新元素添加时会自动更新length属性，会从Array.prototype继承方法

- 伪数组是一个拥有length属性，并且其他属性为负数的普通对象，类数组不能直接调用数组的方法

  **区别：**类数组是简单对象，它的原型关系与数组不同

**类数组转换为数组**

- Array.from()
- Array.prototype.slice.call()
- es6的运算符 [...]

#### 1.3.18 null和undefined的区别

null是定义变量后，赋值null空值。

undefined是定义未赋值，当变量定义未赋值、一个函数没有返回值、访问对象不存在的属性都会返回undefined。

二者值相等，类型不相等

null === undefined           *// false*
null == undefined            *// true*

总结：

1、undefined不是关键字，而null是关键字;

　　var undefined=""  //undefined

　　var null=""   //会报错

2、undefined和null被转换为布尔值的时候，两者都为false;

3、undefined在和null进行==比较时两者相等，全等于比较时两者不等

4、使用Number()对undefined和null进行类型转换时前者为NaN，后者为0

5、undefined**本质上**是window的一个属性，`而null是一个对象`（null不是对象， 虽然typeof null 会输出object，在js最初版本中使用的32位系统，为了性能考虑使用低位存储变量的类型信息，000开头的代表是对象，null全为0，所以会被判定为object）；

#### 1.3.19 ES6中的箭头函数

语法简洁，不能使用arguments、super和new.target  不能用作构造属性、也没有原型prototype属性。没有自己的 this；

- 箭头函数不能作为构造函数使用

- **箭头函数**没有自己的this，它的this其实是继承了外层执行环境中的this，且this指向永远不会随在哪里调用、被谁调用而改变，所以箭头函数不能作为构造函数使用，或者说构造函数不能定义成箭头函数，否则用new调用时会报错；

- 箭头函数的this不会改变

-  箭头函数没有自己的arguments

  箭头函数没有自己的arguments对象。在箭头函数中访问arguments实际上获得的是外层局部（函数）执行环境中的值。

- 箭头函数没有原型prototype 	

- 箭头函数不能用作Generator函数，不能使用yeild关键字	

#### 1.3.20 this指向问题

普通函数中的this指向：指向最后调用它的对象

- 单独的this 和全局函数中（没有被上一级调用）的this 指向window对象；严格模式下是undefined
- 函数调用时，加个new关键字 通过函数生成一个新对象，this指向这个对象

```js
function demo() {
 //alert(this); // this -> object
 this.testStr = 'this is a test';
}
let a = new demo();
alert(a.testStr); // 'this is a test'
```

- 一个没有被上一级对象调用的函数中的this在非严格模式下指向 window；函数被上一级对象调用就指向上一级对象

```js
let name = 'finget'
let obj = {
 name: 'FinGet',
 getName: function() {
 alert(this.name);
 }
}
obj.getName(); // FinGet 指向上一级
---------------------------分割线----------------------------
let fn = obj.getName;
fn(); //finget this -> window
```



- 箭头函数中的this取决于它所继承的外部函数
- 定时器中的this，指向window

```js
setTimeout(function() {
 alert(this); // this -> window ，严格模式 也是指向window
},500)
```

- 元素绑定事件，事件触发后，执行函数中的this指向的是当前元素

```js
window.onload = function() {
 let $btn = document.getElementById('btn');
 $btn.onclick = function(){
 alert(this); // this -> 当前触发
 }
}
```

**改变this指向：**

1. **call**  
   - 改变**函数内部**this指向
   - call()方法调用一个对象。简单理解为调用函数的方式，但是它可以改变函数的this指向。
   - call()主要作用：实现继承

```js
function demo() {
 alert(this);
}
demo.call('abc'); // abc
demo.call(null); // this -> window
demo.call(undefined); // this -> window
```

2. apply
3. bind()

  1、fn.call (newThis,params) call函数的第一个参数是this的新指向，后面依次传入函数fn要用到的参数。会立即执行fn函数。 

  2、fn.apply (newThis,paramsArr) apply函数的第一个参数是this的新指向,第二个参数是fn要用到的参数数组，会立即执行fn函数。 

  3、fn.bind (newThis,params) bind函数的第一个参数是this的新指向，后面依次传入函数fn要用到的参数。  不会立即执行fn函数，且只能改变一次fn函数的指向，后续再用bind更改无效。

- .call()/.apply()/.bind()无法改变**箭头函数**中this的指向

#### 1.3.21 call apply bind

问题：

call apply 的作用、区别是什么

用到call/apply的场景 

 用call判断复杂数据类型

将伪数组转换为数组

ES6 ： [...arguments]

Array.prototype.slice.call(arguments)

```js
 Funtion.prototype.myCall = function(context, ...args){
     		//1.判断调用对象是否是函数
            if(typeof this != 'function') throw new Error('error')
            //2.判断上下文是否存在 不存在设置window
     		context = context || window
     		//3.给传入的对象添加一个fn属性，指向this
            context.fn = this
     		//4.再从这个对象里调用fn方法
            let res = context.fn(...args)
            //5.移除属性
            delete context.fn
            return res
        }
```

手写apply

```js
 Function.prototype.myApply = function(context){
            if(typeof this != 'function') throw new Error('err')

            context = context || window
            context.fn = this
            let res
            if(arguments[1]){
                res = context.fn(...arguments[1])
            }
            else{
                res = context.fn()
            }
            delete context.fn
            return res
 }
```

bind

```js
Function.prototype._bind = function(context,...args){
    let that = this;
    return function(...args2){
        return that.call(context,...args.concat(...args2));
    }
}

var getFn = fn._bind(obj);
var newObj = new getFn();
getFn.prototype.text = '我是被bind方法返回的函数'
console.log(fn.prototype.text) // => undefined
```



三者区别：

- 三者都可以改变函数的this对象指向。
- 三者第一个参数都是this要指向的对象，如果没有这个参数或参数为undefined或null，则默认指向全局window。
- 三者都可以传参，但是apply是数组，而call是参数列表，且apply和call是一次性传入参数，而bind可以分为多次传入，bind是返回绑定this之后的函数，apply、call 则是立即执行。
- bind返回一个原函数的"拷贝"，并拥有指定的 this 值和初始参数；call和apply返回改变this之后调用了该函数的返回值，若该函数没有返回值，就返回undefined。



#### 1.3.22防抖和节流

*防抖就是按B回城，只要回城期间再次按B会重新回城。节流就是技能cd，cd结束才能再次施放。*

定义：

**防抖**：当持续触发事件，一定时间内若没有再次触发事件，就执行一次该事件处理函数；若在设定时间内再次触发， 那就重新开始延时 ，防抖执行的是最后一次触发的时间事件（搜索联想、窗口resize）

```js
// 防抖函数
function debounce(fn,delay){
    let timer = null
    return function(...args){
        //如果定时器以开启 就清除
        if(timer) clearTimeout(timer)
        // 重新计时 计时结束后才执行fn
        timer=setTimeout(() => {
            fn.apply(this, args)
        }, delay);
    }
}
```



**节流：**

当持续触发事件时，保证一段时间内，只调用一次处理函数 

应用场景： 点击事件(提交表单)，高频监听事件、 滚动事件、鼠标不断点击触发

```js
function throttle(fn, delay){
    let timer=null
    return function(...args){
        // 如果定时器存在 直接返回 
        if(timer) return
        // 设置定时任务 到时间后执行fn
        timer = setTimeout(()=>{
            fn.apply(this, args)
            timer = null
        },delay)
    }
}
```

#### 1.3.23 深浅拷贝

**浅拷贝：** 只拷贝对象时仅拷贝对象本身，包括对象的基本变量，而不拷贝对象包含的引用指向的对象，即引用类型数据，拷贝后也是会发生引用；
浅拷贝只复制指向某个对象的指针，而不复制对象本身，**新旧对象还是共享同一块内存。**

- object.agssin()
- 直接赋值
- {…} 扩展运算符

**深拷贝：**
在堆中重新分配内存，并且把源对象所有属性进行新建拷贝，保证拷贝后的对象与原来的对象时完全隔离，互不影响

- `let newobj=JSON.parse(JSON.stringfy(obj))` 

  可以实现数组或对象深拷贝，**但不能处理函数**。

- 递归 循环遍历

- JQuery 可以实现`$.extend(deep,target,object1,objectN)`



方法见csdn总结





#### 1.3.24 new会发生什么

1.创建新的空对象 var obj = {}

2.设置新对象的constructor属性为构造函数的名称，设置新对象的proto属性指向prototype对象，初始化实例：构造函数被传入参数并调用，this指针被设定为指向该实例obj

obj.__proto__ = ClassA.prototype

扩展了对象的原型链

3.使用新对象调用函数，函数中this被指向新的实例对象

ClassA.call(obj)

4.返回this指针。当存在现实的返回时，返回return后面的内容，新建的空对象作废。

我们先了解一下构造函数的new都做了些什么？简单来说，分为四步： ① JS内部首先会先生成一个对象； ② 再把函数中的this指向该对象； ③ 然后执行构造函数中的语句； ④ 最终返回该对象实例。

实现new

```js

const _new = function() {
            // 补全代码
            var obj = {}
            //获取当前函数实参的第一个参数，就是需要创建的对象类型
            var constructor = [...arguments].shift()
            //将新对象的原型设置为构造函数的原型对象
            obj.__proto__ = constructor.prototype
            //绑定this到新对象上
            constructor.call(obj)
            //返回创建的实例对象
            return obj

}
```

#### 1.3.25 简单说说js有哪几种内存泄露的情况

1. 闭包

   解决：使该函数等于null

2. 未被清空的定时器

   解决：当不需要interval或者timeout的时候，调用clearInterval或者clearTimeout

3. 未被销毁的实践监听

   垃圾回收机制不好判断该事件是否需要被解除，导致 callback 不能被释放，此时需要手动解除绑定：DOM.removeEventListener(callback)

4. DOM引用

   ```js
   var a = document.getElementById('id');
   document.body.removeChild(a);
   // 不能回收，因为存在变量a对它的引用。虽然我们用removeChild移除了，但是还在对象里保存着#的引用，即DOM元素还在内存里面。
   解决方法： a = null;
   ```

   

5. 意外的全局变量

   解决：使用 var let const 来定义变量。或者在js文件开头添加 ‘use strict'，开启严格模式。

6. console

   控制台日志记录对总体内存内置文件的影响，也是个重大的问题，同时也是容易被忽略的。记录错误的对象，可以将大量的数据保留在内存中。
   传递给console.log的对象是不能被垃圾回收，所以没有去掉console.log可能会存在内存泄漏.

   解决：删除没必要的log

#### 1.3.26 ES6 新特性

- 新增let、const声明变量，实现了块级作用域

- 新增箭头函数。

- 引入promise、await/async解决异步回调问题

- 引入Class作为对象的模板，实现更好的面向对象编程

  `class `的本质依然是一个函数。

  ```html
  <script>
  	class person {
  		//关键字声明方式
  		constructor(name) {
                    this.name=name
                }           
  		say() {
  			console.log("hello");
  		}
  	}
  
  	var p = new person('p');
  	p.say(); //'hello'
  	console.log(p.name);
  </script>
  
  ```

  class类的继承通过`extends`关键字实现。
  子类必须在`constructor`中调用`super()`,否则无法在构造函数中拿到 this。

  > 因为子类自己的this对象，必须先通过父类的构造函数完成塑造，得到与父类同样的实例属性和方法，然后再对其加工，加上子类自己的实例属性和方法，不调用super，子类拿不到this
  >
  > 这是基于ES6 的继承机制（先将父类实例对象的属性和方法，加到this上面（所以必须先调用super方法），然后再用子类的构造函数修改this）。

  ```js
  <script>
  	class Person {
  		constructor(name, age) {
  			this.name = name;
  			this.age = age;
  		}
  		say() {
  			console.log(this.name + ":" + this.age);
  		}
  	}
  	class Student extends Person {
  		constructor(name, age, sex) {
  			super(name, age);// 调用父类的constructor()，super必须放在前面
  			this.sex = sex;
  		}
  	}
  	var student = new Student("admin", 12, "male");
  	student.name;   //'admin'
  	student.sex;    //'male'
  	student.say(); //'ren:12'
  </script>
  
  ```

  

- 引入模块方便模块化编程,使用 import 和 export 的形式来导入导出模块

- 引入新的数据类型symbol，新的数据结构set和map

- 新增proxy 代理，用于创建一个对象的代理，从而实现基本操作的拦截和自定义（如属性查找、赋值、枚举、函数调用等）

  `var proxy = new Proxy(target, handler)`
  
- 模板字符串

- Symbol 类型

- 新增 **Map**和**Set** 对象

##### 新方法

**数字扩展：**

`parseInt()/praseFloat() /isNaN()`

**数组扩展：**

`Array.from() 将类数组和可迭代的对象（set/map）转换为数组`

`flat() 数组扁平化处理`

数组遍历： `forEach()`

`includes方法`

`map/filter 方法` 返回值：数组

`some() every()` 返回值是true和false

**对象扩展：**

`entries()/keys()/values()` 遍历键、值、键值对

`Object.is()`：严格判断两个值是否相等

`Object.assign()`

`... 扩展运算符`、

对象声明简写：

```js
//es6  声明对象时的属性名与引用的变量名相同就可以省略
      let person={
          name,
          age
      }
```



函数：

参数默认值















#### 1.3.27 宏任务和微任务

宏任务和微任务都是**异步任务。**

**宏任务：**包括整体代码的`script、setTimeout、setInterval、 setImmediate、I/O、 UI rendering`

**微任务：**`Promise.then、process.nextTick、Object.observe, MutationObserver`

执行一个宏任务过程中遇到微任务，就将其放入微任务事件队列中，

当宏任务执行完成后，会查看微任务【事件队列】，并将里面全部的微任务一次执行完。

```js
setTimeout(()=>{
 
console.log("定时器开始执行");
 
})
 
 
new Promise(function(resolve){
 
console.log("准备执行for循环了");
 
for(var i=0;i<100;i++){
 
i==22&&resolve();
 
}
 
}).then(()=>console.log("执行then函数"))；
 
 
console.log("代码执行完毕");
```

执行顺序：

准备执行for循环了-> 代码执行完毕->执行then函数->定时器开始执行



> 所有的代码都写在script标签中，所以**读取所有代码是第一个宏任务**，我们开始执行第一个宏任务。
>
> 我们首先遇到setTimeout，他是第二个宏任务，将它扔进宏任务事件队列里先排队。
>
> 下来我们遇到promise，遇到 new Promise直接执行,**promise执行器里的代码会被同步调用**，所以我们依次打印出2和3。
>
> 下来遇到promise的回调，他是一个微任务，将它扔进微任务事件对列中。
>
> 下来我们接着打印出5，然后执行微任务并且打印出4.
>
> 我们第一个宏任务(script)执行完毕，执行下一个宏任务(setTimeout)，打印出1，到此，所有任务都执行完毕。
>

总结：

- 宏任务 Macrotasks 就是参与了**事件循环的异步任务**。
- 微任务 Microtasks 就是没有参与事件循环的“异步”任务。

**任务执行顺序：**

1.同步任务

2.process.nextTick（微任务）

3.微任务

4.宏任务

5.setImmediate

>  顺序：script(主程序代码)—>process.nextTick—>Promises...——>setTimeout——>setInterval——>setImmediate——> I/O——>UI rendering

当前执行栈执行完毕时会立刻先处理所有微任务队列中的事件，然后再去宏任务队列中取出一个事件。同一次事件循环中，微任务永远在宏任务之前执行。



#### 1.3.28 原型链

> 每个构造函数都有一个prototype原型对象，这个原型对象包含了一个指向构造函数自身的constructor指针，而通过构造函数实例化的对象有一个____proto____属性指向构造函数的prototype。如果让原型对象等于另一个类型的实例，就创造了实例与原型的链条，就构成了原型链。
>
> 从某个对象出发，依次寻找隐式原型的指向，将形成一个链条，该链条叫做[原型链](https://so.csdn.net/so/search?q=原型链&spm=1001.2101.3001.7020)。



1.每个函数function都有一个prototype属性（显示原型），默认指向一个Object空对象，有一个默认属性`constrcutor`，指向函数本身。

```js
function Rabbit() {}
// by default:
// Rabbit.prototype = { constructor: Rabbit }

alert( Rabbit.prototype.constructor == Rabbit ); // true
```



2. 每个实例对象*都有一个____proto____ ,即称为隐式原型（属性）

**对象的隐式原型的值等于对应构造函数的显式原型的值**

*只要用new关键字 + 构造函数生成的对象，就是实例对象*

```js
function Person(){
      this.dog = 'sss'
    }
    const p = new Person()
    console.log(p.__proto__);  //   { constructor: f Person() }
    console.log(Person.prototype); //   { constructor: f Person() }
//  即 p实例对象的  隐式原型__proto__  ==  Person构造函数的  显示原型 prototype

```

- A instanceof B 判断 B函数的显示原型对象prototype在A对象的原型链上

- 所有函数都是Function的实例包括自己

- Object的原型对象是原型链的尽头。当读取实例的属性时，如果找不到，就会查找与对象关联的原型中的属性，如果还查不到，就去找原型的原型，一直找到最顶层为止

- **特殊情况：**
   -Function的隐式原型指向自己的原型
   -Object原型的隐式原型指向null

  - `Object.prototype`就是**原型链**中的最顶层
     Object和 Function都是构造函数，而所有的**构造函数**的都是Function的实例对象,所有的构造函数的__proto__都指向Function的原型.

  `Function.prototype.__proto__===Object.prototype`

  `Function.prototype ===Function.__proto__=== Object.__proto__`

  - Object又是Function的一个实例。

  - > 先有的Object.prototype， Object.prototype构造出Function.prototype，然后Function.prototype构造出Object和Function。

#### 1.3.29 setTimeout的区别

setTimeout 与 setInterval,requestAnimationFrame：

setTimeout 一次性计时器 延迟多长时间去执行 ，相对应关闭计时器的方法是：clearTimeout()

setinterval 循环计时器 ,相对应关闭计时器的方法是： clearInterval()

将setTimeout改造成循环计时器：

```js
function showtime(){
        console.log(1);
        t=setTimeout("showtime()",1000);
}
```

`requestAnimationFrame` 不需要设置时间间隔，采用的是系统时间间隔

特点：

- 会把每一帧中的所有 DOM 操作集中起来，在一次重绘或回流中就完成，并且重绘或回流的时间间隔紧紧跟随浏览器的刷新频率。
- 在隐藏或不可见的元素中，`requsetAnimationFrame` 将不会进行重绘或回流，这就意味着更少的 CPU、GPU 和内存使用量。
- 是浏览器专门提供的 api，在运行时浏览器会自动优化方法的调用，并且页面不是激活状态下，动画会暂停执行，有效节省 CPU 开销

#### 1.3.30 函数柯里化

函数柯里化主要用于给函数分步传递参数，每次传递参数进行处理，并返回一个更具体的函数来接受剩下的参数，这中间可以嵌套多层，直至返回最后的结果。

实现思路：

1. 接收一个处理数据的函数。
2. 定义一个数组用于接收所有的参数。
3. 返回一个函数，如果返回的函数接收的参数的长度是0，则返回fn执行的结果，如果不是0，则将参数push进数组中，并返回函数。

```js
// 手写函数柯里化
const curring = function(fn) {
    const args = [];
    return function result(...rest) {
        if (rest.length === 0) {
            return fn(...args)
        } else {
            args.push(...rest);
            return result;
        }
    }
}
const sum = (...arg) => {
    return arg.reduce((pre,cur) => {
        return pre + cur
    },0)
}

curring(sum)(1)(2,5)(3)()

```





例子：

```js
// 普通的add函数
function add(x, y) {
    return x + y
}

// Currying后
function curryingAdd(x) {
    return function (y) {
        return x + y
    }
}

add(1, 2)           // 3
curryingAdd(1)(2)   // 3

```

像这样，把接受多个参数的函数变换成接受一个单一参数（最初函数的第一个参数）的函数，并且返回接受余下的参数而且返回结果的新函数的技术。我们称呼它为函数柯里化.本质上是对js高阶函数与闭包的一种特殊玩法



#### * 1.3.31 js继承

**1、原型链继承**

将子类的原型链指向父类的对象实例，

```js
function Parent(){
  this.name = "parent";
  this.list = ['a'];
}
Parent.prototype.sayHi = function(){
  console.log('hi');
}
function Child(){

}
Child.prototype = new Parent();
var child = new Child();//child的__proto__指向Child的prototype
console.log(child.name);
child.sayHi();
```

原理：new的一个实例对象的时候，子类的实例child的______proto______指向Child的prototype，Child.prototype指向Parent类的对象实例，该父类对象实例的__proto__指向Parent.prototype,所以Child可继承Parent的构造函数属性、方法和原型链属性、方法。

**优点：** 可继承构造函数的属性，父类构造函数的属性，父类原型的属性；

**缺点：**无法向父类构造函数传参；且所有实例**共享父类实例的属性**，若父类共有属性为引用类型，一个子类实例更改父类构造函数共有属性时会导致继承的共有属性发生变化；

**2、构造函数继承** 借助call

实现方式：在子类构造函数中使用**call或者apply**劫持父类构造函数方法，并传入参数

```js
function Parent(name, id){
  this.id = id;
  this.name = name;
  this.printName = function(){
    console.log(this.name);
  }
}
Parent.prototype.sayName = function(){
  console.log(this.name);
};
function Child(name, id){
  Parent.call(this, name, id);
  // Parent.apply(this, arguments);
}
var child = new Child("jin", "1");
child.printName(); // jin
child.sayName() // Error
```

**原理：**使用call或者apply更改子类函数的作用域，**使this执行父类构造函数**，子类因此可以继承父类共有属性

**优点：**可解决原型链继承的缺点
**缺点：**不可继承父类的原型链方法，构造函数不可复用

**3、组合继承**

类似于es6中的`Object.create()`的方法

原理：综合使用构造函数继承和原型链继承

```js
function Parent(name, id){
  this.id = id;
  this.name = name;
  this.list = ['a'];
  this.printName = function(){
    console.log(this.name);
  }
}
Parent.prototype.sayName = function(){
  console.log(this.name);
};
function Child(name, id){
  Parent.call(this, name, id);
  // Parent.apply(this, arguments);
}
Child.prototype = new Parent();
var child = new Child("jin", "1");
child.printName(); // jin
child.sayName() // jin

var a = new Child();
var b = new Child();
a.list.push('b');
console.log(b.list); // ['a']
```

优点：可继承父类原型上的属性，且可传参；每个新实例引入的构造函数是**私有**的

缺点：会**执行两次**父类的构造函数，消耗较大内存，**子类的构造函数**会**代替**原型上的那个父类构造函数

**4、原型式继承**

原理：用一个函数包装一个对象，返回函数的调用，这个函数可以随意增添属性的实例或对象，结果是将子对象的______proto_____ 指向父对象

```js
var parent = {
  names: ['a']
}
function copy(object) {
  function F() {}
  F.prototype = object; //函数的原型指向被继承的对象   
  return new F();//返回函数的调用
}
var child = copy(parent
```

缺点：共享引用类型

**5、寄生式继承**

原理：二次封装原型式继承，并拓展

```js
function createObject(obj) {
  var o = copy(obj);
  o.getNames = function() {//可以拓展新的属性
    console.log(this.names);
    return this.names;
  }
  return o;
}
```

优点：可添加新的属性和方法

**6、寄生组合式继承**

原理：改进组合继承，利用寄生式继承的思想继承原型

```js
//定义父类
function Person(name){
    this.category = 'human';
    this.legNum = 2;
    this.name = name;
}
 
Person.prototype.sayHello = function(){
    console.log('Hi,i am ' + this.name);
}

//定义继承方法
function inherit(subType,superType){
    //在new inheritFn 的时候将构造函数指向子类
    function inheritFn(){this.constructor = subType}
    inheritFn.prototype = superType.prototype;
    //将子类的原型指向父类原型的一个副本
    subType.prototype = new inheritFn();
}

//定义子类并实现继承

//定义子类构造函数Pan
function Pan(name,age){
    Person.call(this,name);  //借用构造函数
    this.age = age;
}
 
//将子类Pan的原型指向父类Person原型的一个副本
//注意：要执行该动作后才能在Pan的prototype上定义方法，否则没用
inherit(Pan,Person); 
 
Pan.prototype.sayAge = function(){
    console.log(this.age);
}
 
//定义子类构造函数Duan
function Duan(name,hairColor){
    Person.call(this,name);
    this.hairColor = hairColor;
}
 
inherit(Duan,Person);
 
Duan.prototype.showHairColor = function(){
    console.log(this.hairColor);
}

```

```js
//test
//Pan的实例
var pan = new Pan('panfengshan',27);
console.log(pan.name); //panfengshan
console.log(pan.age); //27
console.log(pan.category); //human
console.log(pan.legNum); //2
 
pan.sayHello(); //Hi,i am panfengshan
pan.sayAge(); //27
 
//Duan的实例
var duan = new Duan('duanyanan','black');
console.log(duan.name); //duanyanan
console.log(duan.hairColor); //black
console.log(pan.category); //human
console.log(pan.legNum); //2
 
duan.sayHello(); //Hi,i am duanyanan
duan.showHairColor(); //black
```





7、es6的类继承：extends

[ES6 类 继承 - 范仁义 - 博客园 (cnblogs.com)](https://www.cnblogs.com/Renyi-Fan/p/12029997.html)

`extends`关键字主要用于类声明或者类表达式中，以创建一个类，该类是另一个类的子类。其中`constructor`表示构造函数，一个类中只能有一个构造函数，有多个会报出`SyntaxError`错误,如果没有显式指定构造方法，则会添加默认的 `constructor`方法。

> **为什么子类必须在constructor方法中调用super方法？**

因为子类没有自己的this对象，而是继承父类的this对象，然后对其进行加工。如果不调用super方法，子类就得不到this对象。只有调用super之后，才可以使用this关键字，否则会报错。super()代表调用父类的构造函数,相当于A(父类).prototype.constructor.call(this)

`super`作为**对象**时，在普通方法中，指向父类的原型对象A.prototype；在静态方法中，指向父类。

##### ES5继承和ES6继承的区别

- ES5的继承实质上是先创建子类的实例对象，然后再将父类的方法添加到this上（Parent.call(this)）

- ES6的继承有所不同，实质上是先创建父类的实例对象this，然后再用子类的构造函数修改this。因为子类没有自己的this对象，所以必须先调用父类的super()方法，否则新建实例报错。

  

#### 1.3.32 js构建树型结构数据

构建树型结构数据，一般应用于数据结构类似于,存储的是id和parentid，然后将这种数据结构转换为层级树状格式

```js
const data = [
  { id: 56, parentId: 62 },
  { id: 81, parentId: 80 },
  { id: 74, parentId: null },
  { id: 76, parentId: 80 },
  { id: 63, parentId: 62 },
  { id: 80, parentId: 86 },
  { id: 87, parentId: 86 },
  { id: 62, parentId: 74 },
  { id: 86, parentId: 74 },
];
```

步骤：

1. 遍历data数组
2. 找到当前元素的父元素，在父元素上添加一个对该子元素的引用
3. 元素如果没有父元素，就认为它为根节点

建立id-数组索引的映射关系：

```js
{
  56: 0,
  62: 7,
  63: 4,
  74: 2,
  76: 3,
  80: 5,
  81: 1,
  86: 8,
  87: 6,
};
//建立id-数组索引的映射关系
const idMapping = data.reduce((acc, el, i) => {
  acc[el.id] = i;
  return acc;
}, {});
    
let root;
data.forEach(el => {
  // 判断根节点
  if (el.parentId === null) {
    root = el;
    return;
  }
  // 用映射表找到父元素
  const parentEl = data[idMapping[el.parentId]];
  // 把当前元素添加到父元素的`children`数组中
  parentEl.children = [...(parentEl.children || []), el];
});
    
console.log(root);
```

原理：

为什么可以这么做呢？这是因为，`data` 数组里的每个元素都是内存里的一个对象引用， `forEach`循环里的`el`变量其实是指向内存里的一个对象，`parentEl`也引用了一个对象。

如果内存中的一个对象引用了一个 children 数组，这些子元素同样可以引用自己的子元素数组，这些关联关系都是通过引用完成的。



```js
<script>

    var data = [
        {
            id:1,
            name :"一级分类：1",
            pid :0,
        },
        {
            id:2,
            name :"二级分类：1",
            pid :1,
        },
        {
            id:3,
            name :"三级分类：3",
            pid :2,
        },
        {
            id:4,
            name :"一级分类：2",
            pid :0,
        },
        {
            id:7,
            name :"f级分类：2",
            pid :4,
        },
        {
            id:10,
            name :"f级分类：2",
            pid :7,
        },
        {
            id:9,
            name :"f级分类：2",
            pid :10,
        },
        {
            id:12,
            name :"f级分类：2",
            pid :9,
        },
        {
            id:15,
            name :"f级分类：2",
            pid :12,
        },
        {
            id:13,
            name :"f级分类：2",
            pid :15,
        },
    ]



   function tree(data) {
        let map = {};
        let val = [];
        //生成数据对象集合
        data.forEach(it=>{
            map[it.id] = it;
        })
        //生成结果集
        data.forEach(it=>{
            const parent = map[it.pid];
            if(parent){
                if(!Array.isArray(parent.children)) parent.children = [];
                parent.children.push(it);
            }else{
                val.push(it);
            }
        })
        return val;
    }

    console.log(tree(data))


</script>

```



#### 1.3.33 js变量显式声明和隐式声明

1.显式声明和隐式声明的变量都是挂载在window上
   必须执行隐式声明这代码 全局上才会有这个属性

```js
	var a = 2;
	b = 3;//隐式声明（**为全局变量的一个属性**）
	console.log(window.a) //2
	console.log(window.b) //3

```

2.隐式声明没有变量提升

3.隐式声明的变量可以被delete

4.如果都在全局，他们都是全局变量；如果在函数中，显示声明变量为局部变量，隐式声明为全局变量（函数执行以后）；

#### 1.3.34 Object.is 和 ===的区别

Object在严格等于的基础修复了一些特殊情况的失误（+0 和 -0，NaN和NaN特判）

```js
function is(x,y){
    if(x===y){
        //1/+0 = +Infinity， 1/-0 = -Infinity是不一样的
        return x !==0 || y!==0 || 1/x ===1/y;
    }else{
        //两个都是NaN的时候应该返回true
        return x!==x && y!==y;
    }
}
```

#### 1.3.35 为什么0.1+0.2 !=0.3

js中小数是二进制存储，0.1，0.2, 0.6, 0.8的二进制表示都是无限不循环小数.

二进制转换成十进制，然后十进制转换成字符串，在这个转换的过程中发生了取近似值，所以打印出来的是一个近似值。

`0.2+0.1!=0.3` >0.3

但

0.2-0.1==0.1 ，因为0.2是0.1的2倍



#### 1.3.36 praseFlaot() 和 praseInt()

parseFloat() 方法与parseInt()方法的处理方式相似：从位置0开始查看每个字符，直到找到第一个非有效的字符为止，然后把该字符之前的字符串转换成整数。

不同之处：

- parseFloat()中 将第一个出现小数点看做是有效字符，对于第二个出现的被视为无效。
- parseFloat() 要求输入的字符串必须以十进制表示浮点数。所以，八进制数'010'会被转换成10，而十六进制数'0xF'会被解析成0 

#### 1.3.37 defer 和async的区别

> script标签中没有加defer和async时，浏览器在解析文档时遇到script标签就会停止解析阻塞文档，先加载JS文件，加载完之后立即执行，执行完毕后才能继续解析文档。

defer和async两个属性可以解决DOM渲染阻塞问题，异步加载脚本，执行到script标签时，JS加载和文档解析同时进行

- async ，加载和渲染后续文档元素过程将和script.js的加载与执行并行（异步），异步脚本不能保证它们在页面中出现的次序执行。脚本的加载和执行是紧挨着的，不管声明顺序如何，只要**加载完就会立即执行**
- defer 脚本的执行在所有元素解析完成之后，DOMContentLoaded事件触发之前完成。推迟的脚本原则按照它们被列出的次序执行。
- 两者之间的差别是**script脚本下载完后何时执行**。defer会在**文档解析完之后执行**,并且多个defer会==按照顺序==执行,而**async则是在js加载好之后就会执行,并且多个async,哪个加载好就执行哪个**

#### 1.3.40 事件冒泡

事件冒泡指当一个事件发生在子元素上时，然后会向上传导，导致子元素的父元素上也会触发相同的事件。

引发事件的那个目标元素可以用==event.target==来访问。
 **this**是当前元素，冒泡过程中**不断改变**，event.target是引发事件的目标元素，冒泡过程中**不变**。
==**停止冒泡**：== 

- event.cancelBubble=true;  *在基于ie内核的浏览器中的使用cancelBubble*
- event.stopPropagation();  *在基于firefox内核的浏览器中支持做法stopPropagation*

```js
function preventBubble (obj,event) {
    alert(obj.id);
    var e = (event) ? event : window.event; //先判断浏览器的类型
    if (window.event) {
    	e.cancelBubble=true;// 在基于ie内核的浏览器中的使用cancelBubble
    } else {
    	e.stopPropagation(); //在基于firefox内核的浏览器中支持做法stopPropagation
    }
}
```



##### 事件传播三个阶段

1. 捕获阶段： 从`window`，`document` 和根元素开始，事件向下扩散至目标元素的祖先

2. 目标阶段：事件在用户单击的目标元素上触发

3. 冒泡阶段：事件冒泡通过目标元素的祖先，一直到根元素 `document` 和 `window`。

   > 由`addEventListener(ev, fn, useCapture = false)`第三个参数控制，当`useCapture`为`true`，表示该事件在捕获阶段触发，当`useCapture`为`false`，表示该事件在冒泡阶段触发。默认为false

不支持冒泡的UI事件：load、unload、resize、abort、error
不支持冒泡的焦点事件：blur、focus
不支持冒泡的鼠标事件：mouseleave、mouseenter

==dom0==级事件只有事件冒泡，没有事件捕获

==dom2==级事件涉及到事件捕获，第三个参数布尔值如果为false，就是事件冒泡，否则就是事件捕获



#### 1.3.41 事件委托

**概念：**

把原本需要绑定在子元素的响应事件（click、keydown…）委托给父元素，让父元素担当事件监听的职务。通过事件对象的target属性来控制子级对象的改变。事件委托就是在==冒泡阶段==完成

**原理：**

DOM元素的事件冒泡。

**优点：**

1. 节省内存占用，减少事件注册
2. 可以实现动态绑定事件，当新增子对象时无需再次对其绑定。

**适合事件委托** 的事件有： click ， mousedown ， mouseup ， keydown ， keyup ， keypress 

**场景1：**

>如果我们有⼀个列表，列表之中有⼤量的列表项，我们需要在点击列表项的时候响应⼀个事件
>
>```html
>    <ul id="list">
>     <li>item 1</li>
>     <li>item 2</li>
>     <li>item 3</li>
>     ......
>     <li>item n</li>
>    </ul>
>```
>
>如果给每个列表项⼀⼀都绑定⼀个函数，那对于内存消耗是⾮常⼤的
>
>```js
>// 获取⽬标元素
>const lis = document.getElementsByTagName("li")
>// 循环遍历绑定事件
>for (let i = 0; i < lis.length; i++) {
> lis[i].onclick = function(e){
> console.log(e.target.innerHTML)
> }
>}
>```
>
>这时候就可以事件委托，把点击事件绑定在⽗级元素 ul 上⾯，然后执⾏事件的时候再去匹配⽬标元素
>
>```js
>// 给⽗层元素绑定事件
>document.getElementById('list').addEventListener('click', function (e) {
> // 兼容性处理
> var event = e || window.event;
> var target = event.target || event.srcElement;
> // 判断是否匹配⽬标元素
> if (target.nodeName.toLocaleLowerCase === 'li') {
> console.log('the content is: ', target.innerHTML);
> }
>});
>```

**场景2**

> 如果⽤户能够随时==动态的增加或者删除==列表项元素，那么在每⼀次改变的时候都需要重新给新增的 元素绑定事件，给即将删去的元素解绑事件。
>
> ⽤了事件委托就没有这种麻烦了，因为事件是绑定在⽗层的，和⽬标元素的增减是没有关系的，执 ⾏到⽬标元素是在真正响应执⾏事件函数的过程中去匹配的

**存在的局限性：**

- focus 、 blur 这些事件没有事件冒泡机制，所以⽆法进⾏委托绑定事件
- mousemove 、 mouseout 这样的事件，虽然有事件冒泡，但是只能不断通过位置去计算定位， 对性能消耗⾼，因此也是不适合于事件委托的

#### 1.3.45 解构赋值

ES6 允许按照一定模式，从==数组和对象==中提取值，对变量进行赋值，这被称为解构;

本质上这种写法属于”模式匹配“，只要等号两边的模式相同，左边的变量就会被赋予对应的值。

**作用：**

- 交换变量的值
- 从函数返回多个值 
- 函数参数定义

##### 数组解构

如果等号的==右边不是数组==（或者严格地说，不是可遍历的结构）就**会报错**。

```js
let [a, b, c] = [1, 2, 3];

let [ , , third] = ["foo", "bar", "baz"];
third // "baz"

let [head, ...tail] = [1, 2, 3, 4];
head // 1
tail // [2, 3, 4]

//如果解构不成功，变量的值就等于undefined。
let [x, y, ...z] = ['a'];
x // "a"
y // undefined
z // []

//不完全解构 也可以赋值成功
let [a, [b], d] = [1, [2, 3], 4];
a // 1
b // 2
d // 4

//SET 可以利用数组解构赋值
let [x, y, z] = new Set(['a', 'b', 'c']);

// 报错
let [foo] = 1;
let [foo] = false;
let [foo] = NaN;
let [foo] = undefined;
```

- 解构赋值允许指定默认值。

  ```javascript
  let [foo = true] = [];
  foo // true
  ```

##### **对象的解构赋值：**
**对象结构与数组解构的不同之处**：数组的元素是按**顺序**排的，变量的取值取决于它的位置；对象属性没有次序，**变量必须与属性同名**，才能取到正确的值。

如果解构失败，变量的值等于`undefined`。

对象结构赋值例子：

```js
// 例一 将Math对象上的对数、正弦、余弦三个方法，赋值到对应的变量上
let { log, sin, cos } = Math;

// 例二 将console对象上的log 函数赋值到log变量上就可以直接使用
const { log } = console;
log('hello') // hello
```

**如果变量名与属性名不一样：**

```js
let { foo: baz } = { foo: 'aaa', bar: 'bbb' };
baz // "aaa"
```

==对象的解构赋值的内部机制，是先找到同名属性，然后再赋给对应的变量。真正被赋值的是后者，而不是前者。==

- 对象的解构赋值可以取到继承的属性。

- 对象的解构也可以指定默认值。默认值生效的条件是，对象属性严格等于undefined

- 由于数组本质是特殊的对象，因此可以对数组进行对象属性的解构。

  ```js
  let arr = [1, 2, 3];
  let {0 : first, [arr.length - 1] : last} = arr;
  first // 1
  last // 3
  ```

##### 字符串解构赋值

字符串被转换成了一个类似数组的对象。

```javascript
const [a, b, c, d, e] = 'hello';
a // "h"
b // "e"
c // "l"
d // "l"
e // "o"
```

##### 数值和布尔值的解构赋值

如果等号右边是数值和布尔值，则会先转为对象。

解构赋值的**规则**是，只要等号右边的值**不是对象或数组**，就先将其转为**对象**。由于`undefined`和`null`无法转为对象，所以对它们进行解构赋值，都会报错。

##### 函数参数结构赋值

```js
[[1, 2], [3, 4]].map(([a, b]) => a + b);
// [ 3, 7 ]
```







### 1.4 CSS&布局

#### 1.4.1 继承相关

CSS中的继承：子元素可以继承父元素的属性。

无继承的属性：

```
1、文本属性：
vertical-align：垂直文本对齐
text-decoration：规定添加到文本的装饰
text-shadow：文本阴影效果
white-space：空白符的处理
unicode-bidi：设置文本的方向
2、display 
3、盒子模型的属性：width、height、margin ...
4、背景属性：background、background-color、background-image、background-repeat、background-position、background-attachment

5、定位属性：float、clear、position、top、right、bottom、left、min-width、min-height、max-width、max-height、overflow、clip、z-index

6、生成内容属性：content、counter-reset、counter-increment

7、轮廓样式属性：outline-style、outline-width、outline-color、outline

8、页面样式属性：size、page-break-before、page-break-after

9、声音样式属性：pause-before、pause-after、pause、cue-before、cue-after、cue、play-during 
```

有继承性的属性：
1、字体系列属性

font、font-size、font-style...

2、文本系列的属性：line-height行高

3、元素可见性：visibility

4、表格布局属性：caption-side、border-collapse、border-spacing、empty-cells、table-layout

5、列表布局属性：list-style-type、list-style-image、list-style-position、list-style

6、生成内容属性：quotes

7、光标属性：cursor

8、页面样式属性：page、page-break-inside、windows、orphans

9、声音样式属性：speak、speak-punctuation、speak-numeral、speak-header、speech-rate、volume、voice-family、 pitch、pitch-range、stress、richness、、azimuth、elevation

**所有元素可以继承的属性**

1. ​			元素可见性：visibility 	
2. ​			光标属性：cursor 	

**内联元素可以继承的属性**

1. ​			字体系列属性 	
2. ​			除text-indent、text-align之外的文本系列属性 	

**块级元素可以继承的属性**

1. ​		text-indent、text-align 

#### 1.4.2 css预处理工具

三种主流的**css预处理器**：Less、Sass（Scss）、Stylus（.styl 扩展名）

**Scss特性：**

- 可以用变量，例如（$变量名称=值）；

  ```scss
  $blue:#187ec7;//变量声明
  div{
      color:$blue;//变量引用
  }
  ```

  

- 可以用混合器，例如（）

- 可以嵌套

  ```scss
    .div {
          width:500px;
          .div_Children{
              height:50px;
          }
      }
  ```
  
  
  
  增加了**规则、变量、混入、选择器、继承**等等特性。可以理解为**用js的方式去书写，然后编译成css**
  
  - SCSS 的语法书写和CSS 语法书写方式非常类似，**.sass**文件对代码的排版有着非常严格的要求，而且没有大括号，没有分号；

**sass和less的区别：**

1.变量定义不同：
	Less用**@**，Sass用**$**。

2.**作用域**
	Less	　　变量查找遵循就近原则。
	Sass	　　作用域是有顺序的

3.单位

Less: 当两个数值相加时，若单位不同，以第一个数值的单位为准；

scass: Sass中比较严格，单位不同，不能进行运算.

#### 1.4.3行内元素和块级元素有什么区别，如何相互转换

**行内元素:**

- 和其他元素都在一行
- 高度、宽度是不可控的，设置无效，由内容决定。
- 根据标签语义化的理念，行内元素最好只包含行内元素，不包含块级元素。

**块级元素**

- 高度、宽度、margin及padding都是可控的，设置有效，有边距效果；
- 各个块级元素独占一行，默认垂直向下排列
- 宽度没有设置时，默认为100%；
- 块级元素中可以包含块级元素和行内元素。

使用**display**属性可以实现行内块元素的特性转换：	

(1)`display:inline`;转换为行内元素；

(2)`display:block;`转换为块状元素；

(3)`display:inline-block;`转换为行内块状元素。

(4)display：none 消失，网页中不占任何的位置



#### 1.4.4 块元素的哪些属性可以继承

`text-indent、text-align、visibility、cursor`

#### 1.4.5 说一说盒模型

- **概念**

  CSS盒模型的本质的是一个盒子，他包括：外边距margin、边框（border）、内边距（padding）、实际内容（content）四个属性。

- **标准盒模型和IE盒模型**

  - 标准盒模型：W3C盒子模型

    盒子总宽度（高度） =width/height + padding + border + margin。（==一般宽度不算做margin==）

    ![img](../../source/images/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95/F0AB2FF8B5108D122FBB2FA6C6590556.png)

  

  - IE盒模型：

    盒子总宽度（高度） =width/height + margin 

    ​									= (内容区宽度/高度 + padding + border) + margin。

     *即 width/height 包含了 padding 和 border 值 。*



- **CSS如何设置这两种模型** 	

  标准：`box-sizing: content-box;`( 浏览器默认设置 )
   IE：`box-sizing: border-box; 	`

- **JS如何获取盒模型对应的宽和高** 	

  （1）`dom.style.width/height`只能取到行内样式的宽和高，style 标签中和 link 外链的样式取不到。
   （2）`dom.currentStyle.width/height`（只有IE兼容）取到的是最终渲染后的宽和高
   （3）`window.getComputedStyle(dom).width/height同`（2）但是多浏览器支持，IE9 以上支持。
   （4）`dom.getBoundingClientRect().width/height`也是得到渲染后的宽和高，大多浏览器支持。IE9 以上支持，除此外还可以取到相对于视窗的上下左右的距离。
   （6）`dom.offsetWidth/offsetHeight`包括高度（宽度）、内边距和边框，不包括外边距。

  **最常用，兼容性最好。** 	

#### 1.4.6 BFC(块级格式化上下文)

**概念：**BFC是CSS 布局的一个概念，是一块独立的渲染区域，是一个环境，里面的元素渲染不会影响到外部的元素。只有block-level的box参与。

父子元素和兄弟元素边距重叠，重叠原则取最大值。空元素的边距重叠是取margin与 padding 的最大值。

**原理：**

- 创建BFC元素，它的自动高度需要计算浮动元素
- 内部的BOX会在垂直方向，从顶部一个接一个放置
- box垂直方向的距离由margin决定，属于同一个BFC的两个相邻的Box的margin会发生重叠。
- BFC的区域不会与float 元素重叠

**作用：**

1、自适应两（三）栏布局（避免多列布局由于宽度计算四舍五入而自动换行）
2、避免元素被浮动元素覆盖
3、可以让父元素的高度包含子浮动元素，清除内部浮动（原理：触发父div的BFC属性，使下面的子div都处在父div的同一个BFC区域之内）
4、去除边距重叠现象，分属于不同的BFC时，可以阻止margin重叠 	

**CSS在什么情况下会创建出BFC（即脱离文档流）** 	

 0、根元素，即 HTML 元素（最大的一个BFC）
 1、浮动（float 的值不为 none）
 2、绝对定位元素（position 的值为 absolute 或 fixed）
 3、行内块（display 为 inline-block）
 4、表格单元（display 为 table、table-cell、table-caption、inline-block 等 HTML 表格相关的属性)
 5、弹性盒（display 为 flex 或 inline-flex）
 6、默认值。内容不会被修剪，会呈现在元素框之外（overflow 不为 visible，为overflow） 	

**解决高度塌陷，创建 BFC 块**

**给文字设置成BFC可以解决文字环绕**

#### 1.4.7 IFC（行内格式化上下文）

<img src="../../source/images/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95/CC01CC5BF7B84B6F99B134A44179B21D.png" alt="img" style="zoom:50%;" />

- IFC的布局规则：

（1）内部的Box会在水平方向，从含块的顶部开始一个接着一个地放置；
 （2）这些Box之间的水平方向的margin，border和padding都有效；
 （3）Box垂直对齐方式：以它们的底部、顶部对齐，或以它们里面的文本的基线（baseline）对齐（默认，        文本与图片对其），例：line-heigth与vertical-align。

![1658846514664](../../source/images/前端面试/1658846514664.png)

#### *1.4.8 样式优先级

**样式类型：**

- 行内样式
- 内联样式（<style>标签）
- 外部样式(<link>标签)

##### 选择器类型：

- ID　　#id 
- class　　.class 
- 标签　　p 
- 通用　　* 
- 属性　　[type="text"] 
- 伪类　　:hover 、:link、:visited、:focus、:first-child、:before
- 伪元素　　::first-line 
- 子选择器、相邻选择器 
  - p~ul  选择p元素之后的每一个ul元素
  - div+p 选择所有紧跟在 <div> 元素之后的第一个 <p> 元素
  - div>p 选择所有父级是 <div> 元素的 <p> 元素
  - [title~=flower]  选择title标题属性包含单词"flower"的所有元素
  - [lang|=en]  选择 lang 属性等于 en，或者以 en- 为开头的所有元素
  - [target=-blank] 选择所有使用target="-blank"的元素

**优先规则：**

第一等：代表**内联样式**，如: style=””，权值为1000。
第二等：代表**ID选择器**，如：#content，权值为100。
第三等：代表**类，伪类和属性选择器**，如.content，权值为10。
第四等：代表**标签选择器和伪元素选择器**，如div p，权值为1。
通配符、子选择器、相邻选择器等的。如*、>、+,权值为0。
继承的样式没有权值。

注意：

- 当权值相等时，**后**出现的样式表设置要**优于**先出现的样式表设置； 
- 在同一组属性设置中标有!important规则的优先级最大 
  - !important 的作用是提升优先级，换句话说。加了这句的样式的优先级是最高的（==比内联样式的优先级还高==)。 

#### 1.4.9 盒子塌陷

概念：本应在盒子内部的组件元素跑到了盒子外部

产生原因：父元素大小不够，子元素设置了浮动属性，子元素会跳出父元素的边界，脱离文档流。

若最后父盒子高度为0时，就会影响下面的标准流盒子，影响排版。

**解决办法**

- 最简单，将盒子宽高固定写死，直到合适；
  - 好处：简单方便，兼容性好
  - 缺点：非自适应，影响用户体验
- 给外部父盒子添加浮动，让其脱离标准文档流（方便，但对页面布局不友好，不易维护）
- 给父盒子添加overflow属性，将其属性值设置为：
  - `overflow:auto;` 有可能出现滚动条，影响美观。
  -  `overflow:hidden; `可能会带来内容不可见的问题。

- 父盒子里最下方引入清除浮动块
  - 最简单： <br style="clear:both;"/>

    缺点：引入不必要的冗余元素

##### 清除浮动**

- **使用after伪元素清除浮动**(重要)

​		给外部盒子的after伪元素设置clear属性，再隐藏它

```css
.clearfix {*zoom: 1;}

.clearfix:before,.clearfix:after {

display: table;

line-height: 0;

content: "";

}

.clearfix:after {clear: both;}
```

*缺点：低版本IE不兼容*

-  给父盒子添加border
- 给父盒子设置padding-top

#### 1.4.10 行内元素的margin和padding

水平方向：都有效；

垂直方向：都无效；（padding-top和padding-bottom会显示出效果，但是高度不会撑开，不会对周围元素有影响）

==当margin/padding取形式为**百分比**的值时，无论是left/right，还是top/bottom，都是以父元素的**width**为基数进行渲染的。== 

#### 1.4.11 浏览器如何解析CSS选择器的

CSS选择器的解析是**从右向左**解析的。

#### 1.4.12 min-width、max-width、min/max-height

属性间的覆盖关系：width < max-width < min-width

1.  max-width 会覆盖 width，即使 width 是行内样式或者设置了 !important。 	
2.  min-width 会覆盖 max-width，此规则发生在 min-width 和 max-width 冲突的时候； 	

#### 1.4.13 设置一个元素的背景颜色，背景颜色会填充哪些区域？

background-color设置的背景颜色会填充元素的content、padding和border区域

#### 1.4.14 css3新增内容

- CSS3边框：border-radius、box-shadow、border-image
- CSS3背景：background-size、background-origin（规定背景图片定位区域）
- CSS3文字效果：text-shadow、word-wrap（对长单词进行拆分并换行）
- CSS3 2D转换：transform: translate()、rotate()、scale()
- CSS3 3D转换：transform: rotateX()、rotateY()
- CSS3 过渡：transition
- CSS3 动画：animation
- CSS3用户界面：resize（是否可由用户调整元素尺寸）、box-sizing（定义盒模型）

#### **1.4.15 隐藏页面中某个元素的方法？**

opacity=0；

visibility=hidden；

display：none；

position移到外部；

z-index图层遮盖

##### visibility=hidden, opacity=0, display:none区别

- opacity=0：元素透明度为0，该元素被隐藏起来，但不会改变页面布局，如果该元素已经绑定一些事件，仍能触发
- visibility=hidden：元素不可见但仍然存在，不会改变页面布局，但不会触发该元素已经绑定的事件
- display:none：元素不显示并且会改变页面布局，可理解为该元素从页面中被删除

##### **rgba()和opacity的透明效果有什么不同**

opacity作用于元素，以及元素内的所有内容的透明度

rgba()只作用于元素的颜色或其背景色（设置rgba透明的元素的子元素不会继承透明效果！）



#### **1.4.16 css的单位

css单位有相对长度单位( **em**、ex、ch、**rem**、**vw**、**vh**、vmin、vmax、%)和绝对长度单位之分(cm、mm、in、**px**、pt、pc)，常用的单位有：

`px、em、rem、vh、vw`

- px 像素

- em 浏览器默认 1em = 16px

  为了简化font-size的计算，可以在css中的body选择器中声明 font-size= **62.5%** ，可以使1em = 10px；

  - em的值不是固定的，会继承父级元素的字体大小

- rem 相对HTML**根元素**的font-size值

  同理，为了简化rem与px的转化，在根元素的HTML中声明font-size= **62.5%** ，可以使1rem = 10px；

  - **rem和em不同的是rem相对于根元素，不像em一样使用级联的方式计算尺寸**

- vh、vw：**视窗宽度**的百分比；根据窗口的高度分成100等分，100vh表示满高。

  这里的窗口在桌面端指：浏览器可视区域；

  在移动端指：布局视口

- 百分比 % 

  %百分比，相对长度单位，相对于父元素的百分比值



角度单位：

- deg 度 一个圆=360deg  `transform: rotate(360deg);`
- grad 梯度 一个圆=400grad `transform: rotate(2grad);`
- rad 弧度 一个圆=2π弧度  `transform: rotate(2rad);`
- turn 圈，一个圆=一圈  `transform:rotate(.5turn);`

#### 1.4.17 移动端适配方案

主要思路： 		

1. 按照设计稿的标准开发页面，在手机上部分内容根据屏幕宽度等比缩放，部分内容按需要变化，需要缩放的元素使用 rem, vw 相对单位，不需要缩放的使用 px 	
2. 固定尺寸+弹性布局，不需要缩放 	

1.viewport 适配 

通过设置initial-scale=屏幕的宽度/设计稿的宽度，将所有设备的布局视口宽度调整为设计图的宽度，动态的设置initial-scale的值

```js
//获取meta节点
var metaNode = document.querySelector('meta[name=viewport]');
 
//定义设计稿宽度为375
var designWidth = 375;
 
//计算当前屏幕的宽度与设计稿比例
var scale = document.documentElement.clientWidth/designWidth;
 
//通过设置meta元素中content的initial-scale值达到移动端适配
meta.content="initial-scale="+scale+",minimum-scale="+scale+",maximum-scale="+scale+",user-scalable=no";
```



根据屏幕的宽度设定rem值，需要适配的元素都使用rem单位，不需要的使用px为单位

2.rem适配 +媒体查询 @media可以针对不同的屏幕尺寸设置不同的样式

flexible.js

- 长度单位都用 rem 设置
- 当屏幕尺寸改变时，只需要修改 html 元素的 `font-size` 即可实现等比适配（动态计算并且设置html跟标签的font-size的大小（媒体查询））
- 我们在制作页面的时候，只考虑跟设计稿相同的屏幕尺寸即可，其他尺寸屏幕自动适配

3.vw/vh 

将设计稿的px转成对应的vw，webpack解析css时有个`postcss-px-to-viewport`插件，可以实现px到vw的自动转化。

4.flex弹性布局



##### vue 适配flexible.js的原理

页面引入这个插件后，会在<html>标签添加一个data-dpr和font-size属性，js会获取设备型号，根据不同的型号屏幕大小设置不同的data-dpr的值，然后将页面中元素px单位替换成rem单位，rem相对于根元素<html>的font-size设置的。

使用webpack 的**px2rem-loader** ,自动将px转换为rem

##### 1px问题

物理像素和逻辑像素css会不一样

#### *1.4.18 常问的几个css属性

**display的属性有哪些？**

- `display:none`  隐藏该区域，不占实际空间

- `display:block ` 单独占一行，块级元素，若没设置宽度，默认填满父级元素宽度，margin和padding都有效。

- `display:inline`  多个内联元素占同一行，直到放不下才换行；**不能设置宽高，大小由内容撑开**。**padding上下左右都有效，margin只有左右会产生效果。**

- `display:inline-block`  对外表现为行内元素，和内联元素占一行，对内表现为块级元素，**可以设置width,height等属性。使用margin和padding都有效果。**

- `display:table`   此元素会作为内联表格来显示（类似table），表格前后没有换行符。

  配合table-cell使用可实现水平垂直居中，具体可见：[水平垂直居中](https://blog.csdn.net/qq_41818857/article/details/103752876)

- `display:table-row`   此元素会作为一个表格行显示（类似 tr ）。

- `display:table-cell`   此元素会作为一个表格单元格显示（类似 td 和 th）

- `display:list-item  `

  为元素内容生成一个块型盒，随后再生成一个列表型的行内盒。
  会把元素作为列表显示，要完全模仿列表的话还需要加上 list-style-position，list-style-type

- `display:flex`  多栏多列布局(弹性布局)

  设置flex属性的元素会用伸缩容器减去有实际数值的元素的宽或者高，然后将差值按照flex设置的数值进行比例的分配。

  设为 Flex 布局以后，子元素的`float`、`clear`和`vertical-align`属性将失效。



**position的属性有哪些？**

- **static** 

  默认位置，（static 元素会忽略任何top、bottom、left 或right 声明）覆盖原有的定位，可以把已定位的元素取消定位 

- **fixed** ——相对于浏览器窗口

  固定定位，fixed是相对于window窗口的定位，滚动条滑动，位置不改变。一般在网页中也会经常看到，例如置顶、客服悬浮图标。

- **relative**

  相对定位，相对自身原来位置，原有空间保留，不会被挤占

- **absolute**

  绝对定位；相对于最近的父级元素的定位，如果没有父级元素时相对于窗口的定位；脱离文档流。

- **sticky** 

  粘性定位，在目标范围内，位置固定，设置top/left无效，在滑动过程中，某个元素距离其父元素的距离达到sticky粘性定位的要求时，定位会变成fixed定位，根据设置的left、top等属性固定位置。

  **position:sticky 使用条件** ：

  1. 父元素不能overflow:hidden或者overflow:auto属性。 

  2. 必须指定top、bottom、left、right4个值之一，否则只会处于相对定位 
  3. 父元素的高度不能低于sticky元素的高度 
  4. sticky元素仅在其父元素内生效

- inherit 继承父元素的定位

  如果父级元素是相对于浏览器窗口定位，那么子元素也相对于浏览器窗口定位，而不是父元素。

> 需要注意的是static relative这两个属性值是不会破坏元素的文本属性；但是fixed 和 abosulte则会改变元素的文本流，有float的效果。



#### 1.4.19 flex布局

<http://www.ruanyifeng.com/blog/2015/07/flex-examples.html> 布局练习

**flex布局是什么？**

弹性布局，任何一个容器都可指定为flex布局

```css
.box{
  display: flex;
}
/*行内元素使用flex*/
.box{
  display: inline-flex;
}
/*Webkit 内核的浏览器，必须加上-webkit前缀。*/
.box{
  display: -webkit-flex; /* Safari */
  display: flex;
}
```

**flex容器的属性**（父盒子）

- `flex-dicrection` 决定主轴的方向（即项目的排列方向）。

  属性值：

  - `row`（默认值）：沿水平主轴，元素从左向右排列。
  - `row-reverse`：主轴为水平方向，起点在右端。
  - `column`：元素沿垂直主轴，从上到下垂直排列
  - `column-reverse`：主轴为垂直方向，起点在下沿。

- `flex-wrap`  决定容器内元素的换行(默认不换行)

  属性值：

  - `nowrap`: （默认）不换行；（比如:2个div宽度100%,设置此属性,2个div宽度就自动变成各50%）
  - `wrap`： 换行，第一行在上方
  - `wrap-reverse`：换行，第一行在下方。

- `flex-flow` 该属性是`flex-direction`属性和`flex-wrap`属性的简写形式，默认值为`row nowrap`。

  属性值：

  ```css
  .box {
    flex-flow: <flex-direction> || <flex-wrap>;
  }
  ```

- `justify-content` 决定了元素在主轴上的对齐方式。

  属性值：

  - `flex-start`（默认值）：左对齐
  - `flex-end`：右对齐
  - `center`： 居中
  - `space-between`：两端对齐，元素之间的间隔都相等。
  - `space-around`：每个元素两侧的间隔相等。所以，元素之间的间隔比元素与边框的间隔大一倍。

  ![img](https://www.ruanyifeng.com/blogimg/asset/2015/bg2015071010.png)

- `align-items` 决定元素在垂直轴（交叉轴）的对齐方式

  属性值：

  - `flex-start`：垂直轴的起点（上边）对齐。

  - `flex-end`：垂直轴的终点（下边）对齐。

  - `center`：垂直轴的中点对齐。

  - `baseline`: 元素的第一行文字的基线对齐。

    ![1660108050262](assets/1660108050262.png)

  - `stretch`（默认值）：如果元素未设置高度或设为auto，将占满整个容器的高度。

    ![1660108062868](assets/1660108062868.png)

- `align-content` 在弹性容器内的元素没有占用垂直轴上所有可用的空间时对齐容器内的各项(垂直）；定义了多根轴线的对齐方式。如果项目只有一根轴线，该属性不起作用。

  属性值：

  - `flex-start`：与交叉轴的起点对齐。

  - `flex-end`：与交叉轴的终点对齐。

  - `center`：与交叉轴的中点对齐。

  - `space-between`：与交叉轴两端对齐，轴线之间的间隔平均分布。

  - `space-around`：每根轴线两侧的间隔都相等。所以，轴线之间的间隔比轴线与边框的间隔大一倍。

  - `stretch`（默认值）：轴线占满整个交叉轴。

    ![img](assets/bg2015071012.png)

**设置在容器内元素上的属性**

- `order`  属性定义项目的排列顺序，值为数字。数值越小，排列越靠前，默认为0。

- `flex-grow` 定义项目的放大比例，值为数字，默认为`0`，即如果存在剩余空间，也不放大。

  > 如果所有项目的`flex-grow`属性都为1，则它们将等分剩余空间（如果有的话）。

- `flex-shrink` 定义了项目的缩小比例，默认为1，即如果空间不足，该项目将缩小。

  > 如果所有项目的`flex-shrink`属性都为1，当空间不足时，都将等比例缩小。如果一个项目的`flex-shrink`属性为0，其他项目都为1，则空间不足时，前者不缩小。

- `flex-basis` 在分配多余空间之前，项目占据的主轴空间的大小。浏览器根据这个属性，计算主轴是否有多余空间。它的默认值auto,即项目的本来大小。

- `flex` 

  flex 是`flex-grow`, `flex-shrink` 和 `flex-basis`的简写，默认值为`0 1 auto`。后两个属性可选。

  > 两个快捷值：`auto` (`1 1 auto`) 和 none (`0 0 auto`)。

- `align-self`

  允许单个项目有与其他项目不一样的对齐方式，可覆盖`align-items`属性。默认值为`auto`，表示继承父元素的`align-items`属性，如果没有父元素，则等同于`stretch`。

**注意事项**

- 当子项的总宽度大于父容器的时候，会自动收缩的（弹性的优先级是大于自身固定大小的）
- 当子项的**内容**已经达到了父容器最小宽高的时候，就会出现溢出的现象。

#### 1.4.22 grid 布局

Grid 布局则是将容器划分成“行"和“列”，产生单元格，然后指定"项目所在”的单元格，可以看作是二维布局

**创建容器**

`display:grid`或者`display:inline-grid`来创建一个网格容器，这个元素的所有直系子元素将成为网格项目。

**容器属性：**

- `grid-templete-colums` 列数

  - `grid-templete-rows`行数

    不填写，自动分配

    ```css
    grid-template-columns:100px 100px 100px; // 显示为三列每一列宽度100px 
    grid-template-columns:repeat(3,100px);  //同上
    
    /*autofill 关键字*/
    grid-template-columns: repeat(auto-fill,100px);
    //有时，单元格的大小是固定的，但是容器的大小不确定，这个属性就会自动填充
    
    /*fr 关键字*/
    grid-template-columns:repeat(4,1fr); // 宽度平均分成四等份 
    grid-template-columns:1fr 2fr 3fr;   // 列宽这样是分成6份各占 1 2 3 份 
    
    /*minmax()函数，最小值和最大值*/
    grid-template-columns: 1fr minmax(150px，1fr);  // 第一个参数最小值,第二个最大值
    
    /*auto 关键字*/
    grid-template-columns: 100px auto 100px; //表示第二个元素自动填充
    ```

  - 网格线名称定义 [],方便以后给盒子定位使用

    ```css
    grid-template-columns: [c1] 100px [c2] 100px [c3] 100px [c4]; 
    ```

- `grid-gap / grid-column-gap`  item(项目)相互之间的距离

- `grid-template-areas`  一个区域由单个或多个单元格组成

- `grid-auto-flow`  

  属性值

  - column
  - row

  默认"先行后列".即先填满第一行，再开始放入第二行(就是子元素的排放顺序)

- ` justify-items`(水平方向) 单元格内容对齐方式

- `align-items`(垂直方向) 对齐方式

  值：start、end、center、stretch

- place-items : start end；   这是上面两个属性的简写

- justify-content (水平方向)/ align-content(垂直方向)

  整个内容区域的对齐方式

- grid-auto-columns / grid-auto-rows

**项目属性：**

1.grid-column-start

2.grid-column-end

3.grid-row-start

4.grid-row-end

5.grid-column(1和2的简写形式)

6.grid-row(3和4的简写形式)

7.grid-area

8.justify-self

9.align-self

10.place-self (







#### 1.4.21 css引入样式的方式

1.行内样式（内联样式）

2.内部样式 <style></style>

3.链入外部样式

```html
<link rel="stylesheet" type="text/css" herf="1.css">
```

4.导入外部样式

通过@import 引入，不建议开发使用

**css引用优先级：**

- 就近原则，内部样式、@import都出现在HTML的里面，就近原则，距离修改元素近的优先级高。
- 行内样式>内部样式>link>@import

##### **link和@import的区别**

1、引入的内容不同

link 可以引入样式文件、图片资源等，@import只引入样式文件

2、加载顺序不同

link在页面加载的同时加载，@import在页面加载完以后加载

3、兼容性不同

link是XHTML标签，没有兼容性问题，@import在css2.1提出，低版本的浏览器不支持

4、对js的支持不同

link支持js控制dom去改变样式，@import则不能支持

#### calc() 函数

calc() 函数用于动态计算长度值。

#### 1.4.22 常见的浏览器样式的兼容性问题

- 不同浏览器的标签的默认margin和padding不一样

  解决：

  ```css
  //设置 全局样式
  *{
  margin:0;
  padding:0;
  }
  ```

- 盒模型不一样：计算宽高的方式一样

  - 标准盒模型：box-sizing: content-box; width指content的高度。
  - IE盒模型：box-sizing: border-box;  width指content+padding+border的宽度。

#### 1.4.23 媒体查询

> 可以针对不同的媒体类型定义不同的样式。

> 针对不同的屏幕尺寸设置不同的样式，特别是需要设置设计响应式的页面，@media 是非常有用的。

可以查询的参数有：
 1.viewport(视窗) 的宽度与高度
 2.设备的宽度与高度
 3.朝向 (智能手机横屏，竖屏) 
 4.分辨率等等

媒体查询由多媒体组成，可以包含一个或多个表达式，根据表达式条件判断是否成立，返回true或false。

**媒体类型(mediatype)**
 1.print 打印机
 2.screen 电脑屏幕，平板，智能手机等。
 3.speech语音合成器等发声设备
 4.all 用于所有多媒体类型设备（默认）



常见的媒体特性：

1. device-aspect-ratio设备屏幕宽高比
2. device-height设备屏幕高度
3. device-width设备屏幕宽度
4. aspect-ratio指定设备视口区域的宽高比
5. .orientation方向，横屏landscape还是竖屏portrait



#### 1.4.24 什么是脱离文档流

- 标准流：浏览器按照各种元素标签的排版布局中的默认状态，从左到右，从上到下渲染的排列。
- 脱离文档流就是从普通的布局排版中拿走
- **脱离方法：**
  1. 浮动
  2. 绝对定位
  3. 固定定位

#### 1.4.25 background-position 属性值

- background-position: x% y%。第一个值是水平距离，第二个是垂直距离。左上角: 0% 0%，右下角 100% 100%。如果只指定了一个值，那另一个值默认为50%。

   假如background-position:30% 60%; 也就意味着元素上距离左边30% 上边60%的点应该与图像上同样的点重合。

- background-position:20px 30px;也就表示图像的左上角距离元素左边向右偏移20px，距离上边向下偏移30px



#### 1.4.26 说一下浮动

脱离文档流、盒子塌陷、影响排版

清除浮动：

1.在浮动盒子下方添加一个空白的`div`,添加属性`clear: both`

2.父盒子的高度设置合适的固定值

3.父盒子添加一个 `overflow:hidden` 样式

4.伪元素清除浮动

父级添加after伪类

```css
father::after{     
    content：''；     
    display：table；     
    clear：both ; 
}
```



#### 1.4.27 line-height百分比、 带单位和不带单位的区别

```css
line-height:26px; 表示行高为26个像素
line-heigth:120%;表示行高为当前字体大小的120%
line-height:2.6em; 表示行高为当前字体大小的2.6倍（带单位的行高子元素继承计算值）
line-height:2.6;表示行高为当前字体大小的2.6倍 （子元素直接继承值）
```

带单位的行高，子元素继承的是父元素的计算值

> 例如：
>
> 父元素字体是14px，子元素字体12px,
>
> 那么行高就是28px，子元素虽然字体是12px，行高还是父元素的行高。



不带单位的行高，子元素直接继承这个数字

> 例如：
>
> 元素字体尺寸为14px，行高line-height:2;子元素字体为12px，不需要再定义行高，他默认的行高为24px。（例如：子元素12px，他的行高是24px,不会继承父元素的28px）
>
> ```css
> 元素字体尺寸为14px，
> 行高line-height:2;//行高为28px
> 
> 子元素字体为 12px，
> 继承line-height: 2
> 则他默认的行高为24px。
> （不会继承父元素的28px)
> ```





#### 1.4.28 伪类和伪元素

##### **伪类**

css3中的定义：

- 伪类存在的意义是为了通过选择器找到那些不存在与DOM树中信息(比如`<a>`标签的`:link、:visited`)以及不能被常规css选择器获取到的信息。
- 伪类由一个冒号`:`开头,冒号后是伪类的名称，比如：`:focus 、:hover、:link`

##### 伪元素

定义：

- 伪元素可以创建不存在DOM树中的元素。另外，开发者还可以为伪元素定制样式。
- 使用两个冒号 `::`,区别伪类和伪元素（CSS3中新增的伪元素必须使用两个冒号）
- 一个选择器只能使用一个伪元素，并且伪元素必须处于选择器语句的最后。

伪元素例子： 

`::first-line`向文本的首行添加特殊样式

`::before` 在元素之前添加内容

`::after` 在元素之后添加内容

举个**综合使用伪类和伪元素**的栗子：

```css
q:lang(de)::after{
    content: " (German) ";
}
q:lang(en)::after{
    content: " (English) ";
}
q:lang(fr)::after{
    content: " (French) ";
}
q:not(:lang(fr)):not(:lang(de)):not(:lang(en))::after{
    content: " (Unrecognized language) ";
}

```

以上代码通过伪类`"lang`获取不同`lang`属性的节点，并为之设置伪元素`::after`，伪元素的内容是此节点的语言类型。



**总结一下伪类与伪元素的特性及其区别：**

1. 伪类本质上是为了弥补常规CSS选择器的不足，以便获取到更多信息；
2. 伪元素本质上是创建了一个有内容的虚拟容器；
3. CSS3中伪类和伪元素的语法不同；
4. 可以同时使用多个伪类，而只能同时使用一个伪元素；



#### 1.4.29 为什么 transform： translate（）可以优化

答：因为它不会触发重绘回流

为什么 `transform` 没有触发 repaint 呢？原因就是，`transform` 动画由GPU控制，支持硬件加速。并不需要软件⽅⾯的渲染。

**可以使用GPU加速的CSS3属性：**

- CSS transform
- CSS opacity
- CSS filter

总结：

1、transform 会使⽤ GPU 硬件加速，性能更好；position + top/left 会触发⼤量的重绘和回流，性能影响较⼤。
2、硬件加速的⼯作原理是创建⼀个新的复合图层，然后使⽤合成线程进⾏渲染。
3、3D 动画与 2D 动画的区别；2D动画会在动画开始和动画结束时触发2次重新渲染。
4、使⽤GPU可以优化动画效果，但是不要滥⽤，会有内存问题。
5、理解强制触发硬件加速的 transform 技巧，使⽤对GPU友好的CSS属性。



#### margin 边距重叠

### 1.5 布局（手撕代码？）

#### 1、常见的纯css图形代码（积累）

1.1 纯css实现三角形

把宽高设置为0，边框的宽度设置宽一些，其中三个边透明；

需要展示的边框的宽度：相邻的透明的边框的宽度 = √3 ：1

```css
 div {
             width:0px;height:0px;margin:100px auto;
             border-left:80px solid transparent; 
             border-right:80px solid transparent; 
             border-bottom:138.56px solid #A962CE; /*--三角形的高--*/
        }
或者
div {
    width: 0px;
    height: 0px;
    border: 100px solid red;
    border-top: none;
    border-color: transparent transparent blue transparent;
}
```

1.2 css扇形

左上角是圆角，其余三个角都是直角：左上角的值为宽和高一样的值，其他三个角的值不变（等于0）。

```css
<div class="sector"></div>
<style>
.sector{
  border-radius:80px 0 0;
  width: 80px;
  height: 80px;
  background: #666;
}</style>

```

1.3 圆形

border-radius: 50% 弯曲元素的边框以创建圆。

1.4 画 0.5px 的直线 

- 使用scale缩放

  ```html
  <style>
  .hr.scale-half {
      height: 1px;
      transform: scaleY(0.5);
      transform-origin: 50% 100%;
  }
  </style>
      <p>1px + scaleY(0.5)</p>
      <div class="hr scale-half"></div>
  
  ```

1.5 线性渐变linear-gradient

`linear-gradient(0deg, #fff, #000)`的意思是：渐变的角度从下往上，从白色#fff渐变到黑色#000，而且是线性的

#### 2、三种文档流定位方案

**常规流**

- 普通流中，盒子一个接着一个排列
- 块级格式化上下文里，盒子竖着排列；行内格式化上下文中，盒子横着排列
- 当position为static或relative，并且float为none时会触发普通流
- position：static，盒的位置是常规流布局里的位置
- position：relative，盒偏移位置由top、bottom、left、right属性定义。即使有偏移，仍然保留原有位置，其他常规流不能占用这个位置

**定位流**

- 盒从常规流中被移除，不影响常规流的布局
- 当position为fixed或absolute时为绝对定位元素
- position：absolute，元素定位将相对于上级元素中最近的一个relative、fixed、absolute，如果没有则相对于body

**浮动流**

- 左浮动元素尽量靠左靠上，右浮动同理
- 除非设置clear，否则普通流环绕在其周围
- 浮动元素不影响块级元素的布局，但会影响行内元素的布局，让其围绕在自己周围，撑大父级元素，从而间接影响块级元素布局
- 浮动元素最高点不超过当前行的最高点和其前面的浮动元素的最高点；不超过它的包含块，除非元素本身已经比包含块更宽
- 行内元素只出现在左浮动元素的右边或右浮动元素的左边

#### 3、页面布局方式

| 方式                            | 布局特点                                                     | 设计方法                                                     | 缺点                                                         |
| ------------------------------- | ------------------------------------------------------------ | ------------------------------------------------------------ | ------------------------------------------------------------ |
| 静态布局（Static Layout）       | 无论浏览器尺寸具体多少，网页布局始终按照最初写代码时的布局来实现 | 居中布局，所有样式使用绝对宽度和高度px；屏幕宽高调整时通过滚动条来浏览被遮掩部分 | 不能根据用户的屏幕尺寸做出不同表现                           |
| 流式布局（Liquid Layout）       | 屏幕分辨率变化时，页面内元素的大小会变化而布局不变；屏幕太大或太小都会导致元素无法正常显示 | 使用%定义宽度，px定义高度，配合max-width/min-width控制尺寸流动范围以免过大或过小影响阅读 | 如果屏幕尺寸跨度太大，那么在相对其原始设计而言过小或过大的屏幕上不能正常显示 |
| 自适应布局（Adaptive Layout）   | 屏幕分辨率变化时，页面内元素的位置会变化而大小不会变化       | 创建多个静态布局，每个静态布局对应一个屏幕分辨率范围，屏幕分辨率改变时，切换不同的静态布局（通过@media媒体查询给不同尺寸的设备切换不同样式） | 需要需要为不同的设备开发不同的页面，增加开发成本；当需求改变时可能会改动多套代码，流程繁琐。 |
| 响应式布局（Responsive Layout） | 每个屏幕分辨率下会有一个布局样式，即屏幕分辨率变化时，元素位置和大小都会变 | @media媒体查询+流式布局                                      | 媒体查询是有限的，只能适应主流媒体的宽高                     |
| 弹性布局（rem/em布局）          | 包裹文字的各元素的尺寸采用rem/em做单位（em相对其父元素，rem始终相对html大小，即页面根元素），页面主要划分区域的尺寸仍使用百分数或px | 一般使用rem，根据屏幕大小来控制html元素的font-size，即可自动改变所有用rem定义尺寸的元素的大小 | 只做到了宽度自适应，无法满足一些对高度或者元素间距要求较高的设计 |

1. 流式布局VS响应式布局

   流式布局用于解决类似的设备不同分辨率之间的兼容（分辨率差异较小）；响应式布局用于解决不同设备之间不同分辨率的兼容（分辨率差异较大）

2. 自适应布局VS响应式布局

   共同点：检测设备，根据不同设备采用不同CSS，且CSS都采用百分比确定宽度

   区别：响应式布局在不同设备上看上去是不一样的，会随着设备的改变而改变展示样式；自适应布局在所有的设备上看上去是一样的模板，不过是长度或者图片变小了Flex Box是什么?

##### 响应式布局常用的方法：

- flex布局 
- 媒体查询：`CSS3`媒体查询可以让我们针对不同的媒体类型定义不同的样式，当重置浏览器窗口大小的过程中，页面也会根据浏览器的宽度和高度重新渲染页面。
- rem布局
- vw vh 视口单位

主轴：

![1658846946164](../../source/images/前端面试/1658846946164.png)

![1658847034401](../../source/images/前端面试/1658847034401.png)

![1658847107265](../../source/images/前端面试/1658847107265.png)

![1658847255642](../../source/images/前端面试/1658847255642.png)

#### *4、常见的布局方式

- 两列布局

  > 左右两侧，左侧宽度固定，右侧自适应

  **方法：**

  1. 左侧 float：left；右侧：margin-left：200px；
  2. 左右两侧都 float：left；左侧宽度200px ，右侧宽度使用calc()函数：`calc(100% - 200px);`
  3. 采用flex实现：左侧固定大小，右侧设置 `flex:1`，即可实现自适应

- **三列布局**

  > 左中右三列，左右各 200px 固定，中间自适应占满。

  方法：

  1. 浮动实现：左中使用 `float：left` 往左浮动，右侧往右浮动，左侧和右侧宽度都设为 200px，中间宽度使用 `calc()` 函数实现，代码为：`calc(100% - 200px - 200px);`

     ```html
     // html 代码
     <div class="divBox">
         <div class="left">左侧固定200px</div>
         <div class="content">中间宽度自适应</div>
         <div class="right">右侧固定200px</div>
     </div>
     
     // CSS 代码
      <style>
          * {
              margin: 0;
              padding: 0;
          }
          .divBox {
              height: 500px;
              background-color: pink;
          }
          .left {
              float: left;
              width: 200px;
              height: 100%;
              background-color: royalblue;
          }
          .right {
              float: right;
              width: 200px;
              height: 100%;
              background-color: skyblue;
          }
          .content {
              float: left;
              width: calc(100% - 200px - 200px);
              height: 100%;
              background-color: green;
          }
      </style>
     
     ```

  2. 采用 flex 布局，左右两侧宽度固定大小，中间设置 `flex:1`，即可实现自适应;

  3. 使用position绝对定位实现

     左边left=0，右边right=0，中间的left和right等于左右两边的宽度。

  4. 表格布局实现

- 三行布局

  > **上中下三行，头部 200px 高，底部 200px高，中间自适应占满**

  **方法：**

  使用绝对定位，把上面的和下面的分别设置`top: 0; bottom: 0;`固定在上下两端，中间距离上下各 200px 即可。

- **圣杯布局**（左右两栏固定 中间自适应 ）

  - 圣杯布局是两边固定宽度，中间自适应的三栏布局。
  - 中间栏放到文档流前面，先行渲染。
  - 目的是为了解决三栏布局。

  圣杯布局和双飞翼布局解决的问题是一样的，都是两边固定宽度，中间自适应的三栏布局（与三栏布局的区别是 dom 结构必须是先写中间列部分，这样可以实现中间列优先加载），中间栏要在放在文档流前面以优先渲染。

    ![在这里插入图片描述](assets/20201213164624688.png)

  **实现步骤：**

  1. 首先设置中间三栏： 中、左、右三个div浮动。

  2. 设置中间 `<div class="middle"></div>`的css宽度为100%占满整个大div,那么**此时左右div块会被挤到下方去。**

  3. 此时要设置外层内容区域的div左右`padding`以便给左右div回来时候一个位置。

  4. 接下来我们要使左边栏回到上一行我们要给左盒子一个相对定位（相对于其正常位置进行定位）

     `position:relative`和`margin-left:-100%`（为什么是100%？因为设置100%后它可以刚好和middle中间栏的左侧对齐）;

     添加`right: 200px;`样式属性使其回到第一行的最左侧的padding中。

  5. 右侧同理，只不过只需要 margin 自己本身的宽度。我们给右栏一个`margin-right: -200px;position:relative;right: -200px;`使其回到原来位置，那么这个布局就完成啦。

  

- 双飞翼布局

  **圣杯布局和双飞翼布局比较**

  - 两种布局方式都是把主列放在文档流最前面，使主列优先加载。
  - 两种布局方式在实现上也有相同之处，都是让三列浮动，然后通过负外边距形成三列布局。
  - 两种布局方式的不同之处在于如何处理中间主列的位置：
    - 圣杯布局是利用父容器的左、右内边距+两个从列相对定位。
    - 双飞翼布局是 把主列嵌套在一个新的父级块中利用主列的左、右外边距进行布局调整。

**布局常用方法**

- Flex 布局
- 栅格布局
- 使用 BFC 隐藏属性
- float + margin
- absolute + margin
- 圣杯布局
- 双飞翼布局



扩展：CSS 实现宽度自适应 100%，宽高 16:9 的比例的矩形

```css
    <style media="screen">
      .wrapper {
        overflow: hidden;
        width: 100%;
        height: 0;
        padding-bottom: 56.25%;
        background: red;
      }
    </style>
    <div class="wrapper"></div>
```

width 是根据父元素宽度撑开 100%，padding-top, padding-bottom, margin-top, margin-bottom 取值为百分比的时候，参照的也是父元素的宽度。

#### 文本元素居中

1、水平居中：text-align：center

它只针对容器里面的文字以及容器里面的**display为inline或者inline-block**的容器，如果里面的容器display为block，则里面的容器的内容不会居中。

2、垂直居中：line-height: 容器的高度

3、`vertical-align:middle +display:table-cell`能够使单行文字、多行文字都居中



###  1.6 异步相关

**异步任务的执行不取决于代码的顺序，而取决于某个事件是否发生**。

#### 1.6.1 实现异步的方法

 回调函数（callback）、事件监听、发布订阅 、promise、生成器generator/yield、async/await

- js 的异步编程进化史：callback-> promise->generator->async+await

1. **回调函数 callback**

   优点：简单、容易理解和部署

   缺点：不利于代码阅读和维护，各部分之间高度耦合，流程会很混乱，而且每个 任务只能指定一个回调函数。

   **例子：**

   假定有两个函数f1和f2，后者等待前者的执行结果。

   ```
   f1();
   f2();
   ```

   如果f1是一个很耗时的任务，可以考虑改写f1，把f2写成f1的回调函数;

   ```js
   function f1(callback){
   　　　　setTimeout(function () {
   　　　　　　// f1的任务代码
   　　　　　　callback();
   　　　　}, 1000);
   　　}
   ```

   执行代码：

   `f1(f2)`

   采用这种操作可以把同步操作变成异步操作，f1不会堵塞程序运行。

2. **事件监听**

   一种事件驱动模式，**任务的执行不取决于代码的顺序，而取决于某个事件是否发生**。

   优点：容易理解、可以绑定多个事件，每个事件可以指定多个回调函数，有利于实现模块化；

   缺点：整个程序都要变成事件驱动型，运行流程会变得不清晰。

   **例子：**

   当f1发生done事件，就执行f2

   ```
   f1.on('done', f2);
   ```

   ```js
   function f1() {
     setTimeout(function () {
       // ...
       f1.trigger('done');//f1.trigger('done')表示，执行完成后，立即触发done事件，从而开始执行f2。 
     }, 1000);
   }
   ```

3. **发布/订阅模式（观察者模式）**

   假定存在一个信号中心，某个任务执行完成就像信号中心发布一个信号，其他任务可以订阅这个信号，从而知道自己什么时候开始执行。

   比事件监听方式的优点：可以通过查看消息中心，了解存在多少信号，每个信号有多少订阅者，从而监控程序运行。

4. **promise对象**

   它的思想是，每一个异步任务返回一个Promise对象，该对象有一个then方法，允许指定回调函数。比如，f1的回调函数f2,可以写成：

   `f1().then(f2);`

   f1要进行如下改写（这里使用的是jQuery的[实现](https://www.ruanyifeng.com/blog/2011/08/a_detailed_explanation_of_jquery_deferred_object.html)）：

   ```js
   function f1(){
   　　　　var dfd = $.Deferred();
   　　　　setTimeout(function () {
   　　　　　　// f1的任务代码
   　　　　　　dfd.resolve();
   　　　　}, 500);
   　　　　return dfd.promise;
   　　}
   ```

   优点在于，回调函数变成了链式写法，程序的流程可以看得很清楚，而且有一整套的[配套方法](https://api.jquery.com/category/deferred-object/)，可以实现许多强大的功能。

   比如，指定多个回调函数：`f1().then(f2).then(f3);`

   再比如，指定发生错误时的回调函数：`f1().then(f2).fail(f3);`

   它还有一个前面三种方法都没有的好处：如果一个任务已经完成，再添加回调函数，该回调函数会立即执行。

5. **async/await**

   是Generator 函数的语法糖。

   一个==函数==如果加上 async ，那么该函数就会返回一个 ==Promise==;
   
   await 关键字可以==暂停==异步函数代码的执行，等待期约解决；与生成器函数（generator）中的关键字yield一样
   
   - await等到之后，如果**不是**promise，await会==阻塞后面函数内部==的同步的代码，先执行async外面的同步代码，同步代码执行完，再回到async内部，把这个非promise的东西，作为await表达式结果。
   
     
   
   - 如果await后面是一个promise，还是会在先暂停执行函数内部后面的代码，执行async外面的代码，等着promise对象fulfilled。然后把resolve的参数作为await表达式的运行结果。
   
     如果promise对象状态是rejected，会直接抛出错误，后面的代码会==忽略执行==.
   
     用 `.catch `来错误异常，还可以使用 `try/catch` 来捕获异常.
   
   - 函数会等待 await 返回结果在继续执行，但是 await 内部的代码也依然按正常的同步和异步执行。
   
     如果，await返回结果的函数 `resolve()` 是在 `setTimeout()` 这个 **异步任务** 中：
   
     ```js
     async function fn() {
         console.log(0);
         
         setTimeout(() => {
             console.log(1);
         }, 0);
      
         await new Promise(resolve => {
             setTimeout(() => {
                 console.log(2);
             }, 0);
      
             console.log(3);
      
             setTimeout(() => {
                 console.log(4);
                 resolve();
             }, 1000);
      
             setTimeout(() => {
                 console.log(5);
             }, 0);
         });
      
         setTimeout(() => {
             console.log(6);
         }, 0);
         console.log(7);
     }
      
     fn();
     // 0
     // 3
     // 1
     // 2
     // 5
     // 4（2 秒后）
     // 7
     // 6
     ```
   
     假如 await 代码内返回结果的函数（resolve() 或 reject()）是在 **同步任务** 中执行的话,同步任务 **先于** 异步任务执行的机理，在同步任务执行过程中依次输出了 0、3 后就立即执行了 `resolve()` 使得 await 得到了返回结果，再往后就继续同步的输出了 4，
   
     但是输出 5 的代码是异步任务，与输出 1、2 的代码一并放入任务队列，此时由于 await 返回了结果，所以可以执行 await 以外的代码了，输出 6 是异步任务，于是先输出了同步任务的 7，同步任务都执行完了，最后执行任务队列中的异步任务，按之前进入队列的顺序，就是依次输出 1、2、5、6，所有代码运行结束；
   
     ```js
     async function fn() {
         console.log(0);
      
         setTimeout(() => {
             console.log(1);
         }, 0);
      
         await new Promise(resolve => {
             setTimeout(() => {
                 console.log(2);
             }, 0);
      
             console.log(3);
             resolve();
             console.log(4);
      
             setTimeout(() => {
                 console.log(5);
             }, 0);
         });
      
         setTimeout(() => {
             console.log(6);
         }, 0);
         console.log(7);
     }
      
     fn();
     // 0 
     // 3
     // 4
     // 7
     // 1
     // 2
     // 5
     // 6
     ```
   
     
   
6. Generator 函数是一个状态机，封装了多个内部状态，可暂停函数, ==yield可暂停，next方法可启动==，每次返回的是yield后的表达式结果。

#### promise对象

- `promise.all(iterable)`

语法：` var p = Promise.all([p1, p2, p3]);` 	

> 此实例在iterable参数内所有的promise都“完成（resolved）”或参数中不包含promise时回调完成（resolve）；如果参数中promise有一个失败（rejected），此实例回调失败（reject），失败的原因是第一个失败promise的结果。

(1) 只有p1、p2、p3的状态都变成fulfilled，p的状态才会变成fulfilled，此时p1、p2、p3的返回值组成一个数组，传递给p的回调函数。
(2) 只要p1、p2、p3之中有一个被rejected，p的状态就变成rejected，此时第一个被reject的实例的返回值，会传递给p的回调函数。

- `Promise.race(iterable)`

语法: `var p = Promise.race([p1, p2, p3]);` 

只要p1、p2、p3之中有一个实例率先改变状态，p的状态就跟着改变。那个率先改变的Promise实例的返回值，就传递给p的回调函数。

- promise原理

  **promise 对象用来封装一个异步操作并可以获取其成功/失败的结果值**,Promise 主要是用来解决回调地狱的问题，有三种状态，初始化是pending，成功执行resolve，失败执行reject，then回调onresolved或onrejected 返回一个新的promise对象；

  **说明：then为什么要接收两个参数：**

  then方法最终都要返回一个promise，在then方法执行过程中，需要解析当前promise对象的状态，以及向下一个promise对象传值，如果是pending，不做解析，另外两种状态在设置后会去执行对应状态的队列函数，所以then要接收两个函数，以放到各自的队列函数中

- Promise中then 第二个参数reject和catch有什么区别

  then 里面执行的成功的回调或者是失败的回调，而catch里面执行的是异常处理**错误**的回调。 如果then的第一个函数抛出异常，后面的catch可以捕获所有异常，而then的第二个函数捕获不到。

## 二、性能

### 2.1 前端性能优化手段

可以从以下几个方面入手：

- **加载优化**

  减少HTTP请求，缓存资源、压代码、首屏加载、按需加载、预加载、压缩图像、减少cookie、避免重定向、异步加载第三方资源

- **执行优化**：css 写在头部，js写在尾部并异步、避免img、iframe等的src为空，尽量避免重置图像大小、图像尽量避免使用dataURL

- **渲染优化**：设置viewport、减少dom节点、优化动画、优化高频事件、GPU加速

- **样式优化**： 避免在HTML中书写style、避免css表达式、移除css空规则、正确使用display、不滥用float

- **脚本优化**：减少重绘和回流、缓存dom选择与计算、尽量使用id选择器

**详细解释：**

**加载优化：**

- **减少HTTP请求：**首次加载同时请求数不能超过4个
  - 合并css和js、
  - 使用CSS精灵图、inline Image

- **缓存资源：**使用缓存可减少向服务器的请求数，节省加载时间，所有静态资源都要在服务器端设置缓存，并且尽量使用长缓存(使用时间戳更新缓存)
  - 缓存一切可以缓存的资源
  - 使用长缓存
  - 使用外联样式和脚本

- 压缩代码：减少资源大小加快网页显示速度，对代码进行压缩并在服务端设置Gzip
- 无阻塞：头部内联样式和脚本会阻塞页面的渲染，样式放在头部并使用link方式引入，脚本放在尾部并使用异步方式加载；
- 首屏加载：尽量针对首屏的快速显示做优化
- 按需加载：将不影响首屏的资源和当前屏幕不用的资源放到用户需要时再加载；
  - 懒加载
  
    **图片的懒加载**

    ==data-src== 定义一个属性
  
    浏览器是否发起请求图片是根据<img>的src属性，所以实现图片懒加载的关键就是，在图片没有进入可视区域时，先不给<img>的src赋值，一般换成一张默认的loading图片，这样浏览器就不会发送请求了，等到图片进入可视区域再给src赋值
  
    原理：
  
    > 懒加载就是延迟加载，优先加载可视区域的内容，其他部分等进入了可视区再加载
    >
    > `window.innerHeight `是浏览器可视区的高度
    > `document.body.scrollTop || document.documentElement.scrollTop` 是浏览器滚动的过的距离
    > `imgs.offsetTop` 是元素顶部距离文档顶部的高度（包括滚动条的距离）
    > 图片加载条件：`img.offsetTop < window.innerHeight + document.body.scrollTop;`
    >
    > ![1666753376883](assets/1666753376883.png)
  
    参考代码：
  
    ```js
    var imgs = document.querySelectorAll('img');
    function lozyLoad(){
    		var scrollTop = document.body.scrollTop || 	document.documentElement.scrollTop;
    		var winHeight= window.innerHeight;
    		for(var i=0;i < imgs.length;i++){
    			if(imgs[i].offsetTop < scrollTop + winHeight ){
    				imgs[i].src = imgs[i].getAttribute('data-src');
    			}
    		}
    	}
      window.onscroll = lozyLoad();
    ```
  
    **数据懒加载**
  
    > 场景：当主页又很多个模块，每个模块都发ajax请求拿数据，并且是在组件创建时发送请求，这样有一个后果：靠近底层的模块其实用户看不到，这个发请求有点浪费。
    >
    > https://www.jianshu.com/p/24e3943140d6
  
  - 滚屏加载
  
  - media Query（媒体查询）加载
  
- 压缩图像
- 减少cookie：cookie会影响加载速度
- 避免重定向
- 异步加载第三方资源

**执行优化**

- CSS写在头部
- 避免img。iframe等的src为空：空src会重新加载当前页面，影响速度和效率
- 避免重置图像大小，会引发重绘
- 图像尽量避免使用DataURL：DataURL图像没有使用图像的压缩算法，文件会变大，并且要解码后再渲染，加载慢耗时长

**渲染优化：**

- 设置viewpoint HTML的鹅viewpoint会加速页面渲染
- 减少dom节点
- 优化动画
  - 尽量使用css3动画
  - 适当使用canvas动画

- 优化高频事件（scroll、touchmove等事件可导致多次渲染）
  - 函数节流
  - 函数防抖
  - 使用requestAnimationFrame监听帧变化：使得在正确的时间进行渲染
- GPU加速：使用某些HTML5标签和CSS3属性会触发GPU渲染，请合理使用(**过渡使用会引发手机耗电量增加**)
  - HTML标签：video、canvas、webgl 			
  - CSS属性：opacity、transform、transition

**样式优化：**

- 正确使用display：display会影响页面的渲染
  - display:inline后不应该再使用float、margin、padding、width和height 			
  - display:inline-block后不应该再使用float 			
  - display:block后不应该再使用vertical-align 			
  - display:table-*后不应该再使用float和margin 			

### 2.1 如何使用css提高页面性能

- 内联首屏**关键**css

- 异步加载css

  - 使用js将link标签插到head标签后
  - 设置link标签media属性为noexis，浏览器会认为当前样式表不适用当前类型，会在不阻塞页面渲染的情况下再进行下载。加载完成后，将`media`的值设为`screen`或`all`，从而让浏览器开始解析CSS
  - 通过rel属性将link元素标记为alternate可选样式表，也能实现浏览器异步加载。同样别忘了加载完成之后，将rel设回stylesheet；

- 资源压缩：

  利用`webpack`、`gulp/grunt`、`rollup`等模块化工具，将`css`代码进行压缩，使文件变小，大大降低了浏览器的加载时间

- 合理使用选择器

  - 不要嵌套使用过多复杂选择器，最好不要三层以上
  - 使用id选择器就没必要再进行嵌套
  - 通配符和属性选择器效率最低，避免使用

- 减少使用昂贵的属性

  在页面发生重绘的时候，昂贵属性如`box-shadow`/`border-radius`/`filter`/透明度/`:nth-child`等，会降低浏览器的渲染性能

- 尽量不使用@important 引入css样式文件

  `@import`会影响浏览器的并行下载，使得页面在加载时增加额外的延迟，增添了额外的往返耗时

  而且多个`@import`可能会导致下载顺序紊乱

- 减少重排操作，以及减少不必要的重绘

### 2.3 SPA单页面应用 首屏加载 速度慢怎么解决

首屏时间（First Contentful Paint），指的是浏览器从响应用户输入网址地址，到首屏内容渲染完成的时间，此时整个网页不一定要全部渲染完成，但需要展示当前视窗需要的内容

**在页面渲染的过程，导致加载速度慢的因素可能如下：**

- 网络延时问题
- 资源文件体积是否过大
- 资源是否重复发送请求去加载了
- 加载脚本的时候，渲染内容堵塞了

**解决方案：**

- 减小入口文件体积

  常用的手段是**路由懒加载**，把不同路由对应的组件分割成不同的代码块，待路由被请求的时候会单独打包路由，使得入口文件变小，加载速度大大增加

- 静态资源本地缓存

  后端返回资源问题：

  - 采用`HTTP`缓存，设置`Cache-Control`，`Last-Modified`，`Etag`等响应头
  - 采用`Service Worker`离线缓存

  前端合理利用localstorage

- UI框架按需加载

### 2.4 如何使用webpack优化前端性能

用webpack优化前端性能是指优化webpack的输出结果，让打包的最终结果在浏览器运行快速高效。

- **压缩代码**：删除多余代码、注释、简化代码写法
- **利用cdn加速**： 在构建过程中，将引用的静态资源路径修改为CDN上对应的路径。可以利用webpack对于`output`参数和各loader的`publicPath`参数来修改资源路径
- **Tree Shaking**: 将代码中永远不会走到的片段删除掉。可以通过在启动webpack时追加参数`--optimize-minimize`来实现
- 提取公共第三方库： SplitChunksPlugin插件来进行公共模块抽取,利用浏览器缓存可以长期缓存这些无需频繁变动的公共代码

> cdn缓存就是给网络请求信号一个暂时存储的寄存器，在cdn数据库中会缓存着大量的网络请求信号。然后cdn数据库会根据目前网络服务器的状态，进行不同网络请求信号的分配。
>
> CDN的工作原理就是将您源站的资源缓存到位于全国各地的CDN节点上，用户请求资源时，就近返回节点上缓存的资源

### 2.5 css加载会造成阻塞吗

- css加载**不会**阻塞DOM树的解析
- css加载**会**阻塞DOM树的渲染
- css加载**会**阻塞后面js语句的执行

解决办法：

- 使用CDN
- 对css压缩
- 合理使用缓存
- 减少http请求数

### 2.5 假如浏览器并发请求有5个限制，怎么办？多了，如何提高性能

- 减少图片资源的请求数量：使用精灵图，将小图片合并成一张大图片，通过css的background背景精灵图定位显示；
- 设置cache-control max-age：对于某些长期不会发生改变的资源，通过这两个属性设置长时间的缓存，减少浏览器对资源的重新请求
- 懒加载，在用户没有浏览的到地方没比要进行图片加载，节点创作，等到用户滚动到节点内容区域内再显示加载内容。





## 图

### Eacharts

可视化数据图形,使用步骤：

1. 创建一个具备Echarts大小的DOM

```html
<div id="main" style="width:200px;height:200px"></div>
```

2. 初始化视图

```js
var myChart = eachart.init(document.querySelector('#main'))
```

3. 样式配置和数据

```js
 var option = {
            title: {  // 标题
                text: 'ECharts 入门示例'
            },
            tooltip: {},  // 鼠标悬停气泡
            legend: {  // 图例
                data:['销量']
            },
            xAxis: { // 配置横轴类别
                data: ["衬衫","羊毛衫","雪纺衫","裤子","高跟鞋","袜子"]
            },
            yAxis: {},  // 配置纵轴类别
            series: [{  // data参数，通过函数进行数据返回渲染
                name: '销量',
                type: 'bar',
                data: [5, 20, 36, 10, 10, 20]
            }]
};
```

4. 渲染图示表

```js
myChart.setOption(option);

```

图表名词：

1. line 折线图
2. bar 柱形图
3. pie 饼图

#### 切换其他统计图时，出现卡顿或者数据还存在的问题怎么办

1.把返回的数据清空

2.销毁这个统计图资源，在mounted()方法和destroy()方法之间加一个beforeDestroy()方法释放该页面的chart资源，clear()方法则是清空图例数据，不影响图例的resize，而且能够释放内存，切换的时候就很顺畅了

```
beforeDestroy () {this.chart.clear()},
```

3.echarts的series（系列）属性：



#### 数据量大如何 优化卡顿

- 在散点（气泡）图中可以配置large参数，开启大数据量优化，在serise中加入，

```
large: true,
largeThreshold: 1000,
```

- 取消一切不必要的动画效果，气泡，减小体积

- 配置`dataZoom` 组件 用于区域缩放，控制数轴的显示范围，从而能自由关注细节的数据信息，或者概览数据整体，或者去除离群点的影响。

  `dataZoom` 的运行原理是通过 `数据过滤` 以及在内部设置轴的显示窗口来达到 `数据窗口缩放` 的效果。

- 和后台开发人员讨论，对数据进行压缩，减少数据量

#### echarts 图表自适应 div resize 问题

 echart图表本身是提供了一个`resize`的函数的。

用于当div发生resize事件的时候，让其触发echart的resize事件，重绘canvas。



#### ECharts如何画图

echarts 是通过canvas来是实现的，由于canvas的限制，所以echarts在实现的时候多是绘制一些规则的，可预期的，易于实现的东西。

echarts的核心就是options配置的对象。一般使用最多的是直角坐标图，极点图，饼状图，地图。

对于直角坐标，必须配置xAsix和yAxis

series系列的认识，它是一个数组，数组的每一项都代表着一个单独的系列，可以配置各种图形等等功能。

data一般是一个每一项都是数组的数组，也就是嵌套数组。里层数组一般代表坐标位置

### canvas 

1. canvas 元素是html5的核心功能之一，使用 JavaScript 在网页上绘制图像。 
2. 画布是一个矩形区域，您可以控制其每一像素。 	
3. 每次更改某个canvas元素，此canvas元素都需要整体重绘。 	
4. 无法只修改某个canvas元素的某一部份。 	
5. canvas 拥有多种绘制路径、矩形、圆形、字符以及添加图像的方法。 	
6.  canvas 元素本身没有绘图能力。 
7.   图像既可以绘制在canvas里，也可以绘制在canvas之外 
8. canvas的缩放需要通过context的scale()、transform方法。
9.   canvas不可获取焦点，所以不能在canvas元素上新增键盘事件监听器。 	

## 安全

### CSRF/XSRF(跨站请求伪造)

攻击者盗用用户身份，以用户名义发送恶意请求..

> 诱导用户跳转到新的页面，利用 服务器的验证漏洞 和 用户之前的登入状态，来模拟用户进行操作

防御措施：

- 显示验证方式：添加验证码、密码
- 请求地址添加token验证，使黑客无法伪造用户请求
- 同源检测，检查HTTP头部的Referer 字段，确定请求来源进行过滤
- 涉及数据的修改操作使用post请求而不是get请求
- 双重cookie验证：在用户访问网站页面时，向请求的域名注册一个cookie，内容为随机字符串等；在前端向后端发请求时，在URL中将这个cookie参数添加进去，后端接口验证Cookie中的字段与URL中的参数字段是否一致，不一致就拒绝请求。
- 利用cookie的sameSize属性规定其他网站不能使用本网站的cookie。



### XSS攻击（跨站脚本攻击）

攻击者在页面中嵌入恶意JS脚本，当用户浏览该页面时进行攻击，然后获取用户的敏感信息（cookie、session）。本质是数据被当做程序执行。

xss类型：

- 持久型XSS：将脚本移植到服务器上，导致每个访问的用户都会执行
- 非持久型XSS：对个体用户的某个URL的参数进行攻击

防御措施：

- 现在大部分浏览器自带xss筛选器，vue/react框架也对xss进行一些防护。

- 对于用户输入的内容和服务器端返回的内容进行过滤，尤其是特殊字符

- 重要的内容加密传输

- cookie设置httponly和secure；

  - httponly：该属性会禁止JS脚本使用document.cookie来访问cookie，有效防止xss攻击

  - secure：该属性告诉浏览器仅在请求为HTTPS连接的时候才发送cookie

    secure属性是防止信息在传递的过程中被监听捕获后信息泄漏，HttpOnly属性的目的是防止程序获取cookie后进行攻击。

### CDN劫持

出于性能考虑，前端应用通常会把一些静态资源存放到CDN，如果攻击者劫持了CDN，或者对CDN中的资源进行了污染，攻击者可以肆意篡改我们的前端页面，对用户实施攻击。

防御：

script 和 link 标签有了新的属性 **integrity**，这个属性是为了防止校验资源完整性来判断是否被篡改。

它通过 **验证获取文件的哈希值是否和你提供的哈希值一样来判断资源是否被篡改**。
使用 SRI 需要两个条件：一是要保证 **资源同域** 或开启跨域，二是在中 **提供签名** 以供校验。



### DOS、 DDOS攻击原理和防范 

https://blog.csdn.net/weixin_44221613/article/details/88410627















## 操作系统

### 1、进程和线程

**进程**是具有一定功能的程序，是系统进行资源分配调度的基本单位（进程=程序+数据）；

> 每个进程都有独立的代码和数据空间（进程上下文），进程间的切换会有较大的开销

**线程**是进程的一个实体，是CPU调度分配的基本单位，线程之间基本上不拥有系统资源。

一个程序至少有一个进程，一个进程至少有一个线程，资源分配给进程，同一个进程下所有线程共享该进程的资源。



**线程哪些资源共享？哪些资源不共享？**

共享：堆、全局变量、静态变量、文件等共用资源

独享：栈、寄存器



### 进程调度算法

1. 先来先服务

2. 短作业优先

3. 优先级调度

4. 高响应比优先调度

5. 时间片轮转调度 

6. 多级反馈队列调度

   设置多个就绪队列，每个队列赋予不同的优先级；每个队列采用FCFS算法，新进程进入时首先放入第一队列末尾，若第一个时间结束未完成，将其转入第二队列末尾……。队列按优先级调度，仅当前一队列空闲时才调用下一队列。

### 进程间的通信方式

- 管道：一条管道只能一个进程写，一个进程读。
- 消息队列：可以边发送边接收，而不需要等待完整的数据
- 共享内存：共享内存的机制就是，不同的进程拿出一块虚拟内存空间，映射到相同的物理内存空间。
- 信号量：信号量代表着资源的数量，信号量本质上是一个整型的计数器，用于实现进程间的**互斥**和**同步**
- 信号
- socket：Socket不仅可以跨网络和不同主机进行进程间通信，还可以在同一主机进行进程间通信。



### 死锁

**死锁**是两个或两个以上进程在执行过程中，由于竞争资源或者由于彼此通信而造成的一种阻塞现象；若无外力干预，它们都将无法推进下去。

产生原因：系统资源不足；进程运行推进顺序不当；资源分配不当

产生条件：互斥、请求与保持、不剥夺、循环等待

解决死锁：

死锁预防、死锁避免、死锁的检查与恢复

**银行家算法**

### 并发

并发：逻辑上的同时发生，强调有处理多个任务的能力但不一定要同时。一个处理器快速循环执行多个任务
并行：物理上的同时发生，强调有同时处理多个任务的能力。多个处理器同时处理多个任务







 信号量同步 

 读写锁

路由器、网桥、交换机工作在哪一层，具体干什么



### LRU缓存算法（最近最少使用算法）

LRU算法主要用于缓存算法，在节省资源的情况下提高数据访问效率。
筛选热点数据：对不断访问的数据进行筛选淘汰，剩下的数据就为热点数据；相对而言，释放最近未被访问数据占用的空间也是采用LRU算法。

> 假设缓存的大小固定，初始状态为空。每发生一次读内存操作，首先查找待读取的数据是否存在于缓存中，若是，则缓存命中，返回数据；若否，则缓存未命中，从内存中读取数据，并把该数据添加到缓存中。向缓存添加数据时，如果缓存已满，则需要删除访问时间最早的那条数据，这种更新缓存的方法就叫做LRU。

实现：HashMap+双向链表实现

```c++
struct Node {
    int key;
    int val;
    Node* next;
    Node* prev;
    Node(int _key,int _val) :key(_key),val(_val), next(nullptr), prev(nullptr) {}
};

class Solution {
public:
    unordered_map<int, Node*> hash;
    Node* head;
    Node* tail;
    int cap;
    int size;
    Solution(int capacity) {
        // write code here
        size = 0;
        cap = capacity;
        head = nullptr;
        tail = nullptr;
        hash.clear();
    }
    void removetohead(Node* p) {
        if (p == head) {
            return;
        }
        p->prev->next = p->next;
        if (p == tail) {
            tail = p->prev;
        }
        else {
            p->next->prev = p->prev;
        }
        p->prev = nullptr;
        p->next = head;
        head->prev = p;
        head = p;
        return;
    }
    int get(int key) {
        // write code here
        if (hash.find(key) == hash.end()) {
            return -1;
        }
        else {
            removetohead(hash[key]);
            return hash[key]->val;
        }
    }

    void set(int key, int value) {
        // write code here
        if (hash.find(key) != hash.end()) {
            //key已经存在
            hash[key]->val = value;
            removetohead(hash[key]);
        }
        else {
            //key不存在
            if (size < cap) {
                //缓存未满，直接在头部插入
                Node* p = new Node(key,value);
                if (head == nullptr) {
                    head = tail = p;
                }
                else {
                    head->prev = p;
                    p->next = head;
                    head = p;
                }
                hash[key] = head;
                size++;
            }
            else {
                //缓存已满，更新尾，将尾移到头
                int k = tail->key;
                hash.erase(k);
                tail->key = key;
                tail->val = value;
                removetohead(tail);
                hash[key] = head;
            }
        }
    }
};
```



## 设计模式

使用设计模式是为了可重用代码、让代码更容易被他人理解、保证代码可靠性。设计模式使代码编制真正工程化。

**设计模式的三个分类**

**创建型模式：对象实例化的模式，创建型模式用于解耦对象的实例化过程。**

**结构型模式：把类或对象结合在一起形成一个更大的结构。**

**行为型模式：类和对象如何交互，及划分责任和算法。**

### 23种设计模式的关键点

#### **创建型模式**

- **单例模式：** 某个类只能有一个实例，提供一个全局的访问点。
- **工厂方法模式**：定义一个创建对象的接口，由子类决定要实例化的类是哪一个，也就是说工厂方法模式让实例化推迟到子类。
- **抽象工厂模式**：创建相关或依赖对象的家族，而无需明确指定具体类。
- **建造者模式**：封装一个复杂对象的构建过程，并可以按步骤构造。
- **原型模式**：通过**复制**现有的实例来创建新的实例。优点就是简化了新对象的创建过程，提高了效率。

#### **结构型模式**

- **适配器模式**：将一个类的方法接口转换成客户希望的另外一个接口。作为中间件的适配器将目标类和适配者解耦，增加了类的透明性和可复用性。
- **桥接模式**：将抽象部分和它的实现部分分离，使它们都可以独立的变化，重在连接不同的东西。
- **组合模式**：将对象组合成树形结构以表示“部分-整体“的层次结构。叶子对象和组合对象实现相同的接口。这就是组合模式能够将叶子节点和对象节点进行一致处理的原因。
- **装饰器模式**：动态的给对象添加新的功能
- **外观模式**：隐藏系统的复杂性，对外提供一个统一的方法，来访问子系统中的一群接口。
- **享元模式**：通过共享技术来有效的支持大量细粒度的对象。
- **代理模式**：为其他对象提供一个代理以便控制这个对象的访问。

#### **行为模式**

- **访问者模式**：在不改变数据结构的前提下，增加作用于一组对象元素的新功能。
- **模板模式**：定义一个算法结构，而将一些步骤延迟到子类实现。基于继承的代码复用技术。
- **策略模式**：定义一系列算法，把他们封装起来，并且使它们可以相互替换。
- **状态模式**：允许一个对象在其对象内部状态改变时改变它的行为。
- **观察者模式**：定义了对象间的一对多的依赖关系。当一个对象改变状态时，它的所有依赖者都会收到通知并且自动更新。
- **备忘录模式**：在不破坏封装的前提下，保持对象的内部状态，可以使系统恢复到某一特定的历史状态
- **中介者模式**：用一个中介对象来封装一系列的对象交互。
- **迭代器模式**：提供一种方法顺序访问一个聚合对象中的各个元素，而不是暴露其内部的表示。
- **解释器模式**：定义语言的文法，并且建立一个解释器来解释该语言中的句子
- **命令模式**：将请求封装成对象，以便使用不同的请求、队列或者日志来参数化其他对象。同时命令模式支持可撤销的操作。
- **责任链模式**：将请求的发送者和接收者解耦，让多个对象都有可能接收请求，将这些对象连接成一条链，并且沿着这条链传递请求，直到有对象处理它为止













**一、单例模式（创建型模式）**

单例类只能有一个实例；单例类必须自己创建自己的唯一实例；单例类必须给所有其他对象提供这一实例

**二、观察者模式（行为型模式）**

对象间存在一对多关系

目的：当一个对象被修改时，则会自动通知它的依赖对象

主要解决：一个对象状态改变给其他对象通知的问题，且要考虑易用和低耦合，保证高度的协作

**三、发布-订阅模式（广义上的观察者模式）**

发布者和订阅者不知道对方的存在，需要一个第三方组件，即信息中介将订阅者和发布者串联起来，它过滤和分配所有输入的消息











## 计算机网络

### 网络模型和网络协议

![1658406755411](../../source/images/前端面试/1658406755411.png)

**物理层and数据链路层协议：**

- ARP协议 地址解析协议

  用于映射计算机的物理地址和临时指定的网络地址IP，据IP地址查询物理地址。

  - RARP协议（反向地址转换协议）：它跟ARP相反，它是根据物理地址查询IP地址。

**网络层协议**

- IP协议
- ICMP协议 ：因特网控制报文协议，它是TCP/IP协议族的一个子协议，用于在IP主机、路由器之间传递控制消息。
- IGMP协议：(因特网组管理协议)是因特网协议家族中的一个组播协议，它运行在主机和路由器之间。

**传输层协议：**

- TCP 传输控制协议：它是一种面向连接，可靠，基于字节流的传输层通信协议。
- UDP 用户数据报协议 ：它是提供一种面向事物的简单不可靠信息传送服务。(比如语音视频聊天用的就是UDP协议)

**应用层协议：**

建立在TCP上的协议：

- FTP 文件传输协议
- SMTP 简单邮件传送协议
- HTTP 超文本传输协议

建立在UDP上： 

- DNS 域名系统
- SNMP 网络管理协议
- NFS
- TFTP

会话层：

- SMTP
- DNS

表示层

- SNMP
- TeInet

### TCP 拥塞控制

即`慢开始`、`拥塞避免`、`快重传`和`快恢复`。



### 集线器、交换器、路由器分别在哪一层

**物理层** 

- 中继器：连接同一个网络的两个或多个网段
- 集线器：对接收到的信号进行同步整形放大

**数据链路层：**

- 交换机：识别数据包中的MAC地址信息，根据MAC地址进行转发，并将这些MAC地址与对应的端口记录在自己内部的一个地址表中。
- 网桥、网卡

**网络层：**

- 路由器：可以连接多个网络或网段的网络设备，能将不同网络或网段之间（比方局域网——大网）的数据信息进行转换。IP 数据报的转发
- 网关



## git命令

git clone



### git冲突解决

版本回退

1.1当已经提交修改，但是想回到修改前的样子时，可使用版本回退

git reset --hard + 版本号

合并分支语句 git merage

git status 看存在哪些冲突

将冲突都解决，并提交后，程序试运行，看是否能跑，能跑再push

### 常用命令

  checkout 切换 

  merge 合并（拉代码或者push代码都可使用） 

  rebase 合并（拉公共分支最新代码的时候使用） 

  push 本地分支->远程主机 

  git bisect是利用二分法的思想，来查找哪一次代码提交引入了错误  

  git stash 暂存  

#### 撤销push

`git log `找到最近一次commit的版本号

`git reset --soft 版本号 `  或者 `git reset --soft HEAD~`   本地代码不会回退

或者用 ` git reset –-hard 版本号` 本地代码会直接回退提交前版本（慎用）

回退之后再重新push



## 应用场景题

### 下拉刷新和上拉加载

**下拉刷新：**

1. 监听原生的touchstart事件，记录初始位置的值`e.touches[0].pageY`
2. 监听touchmove事件，记录并计算当前滑动的位置与初始位置的差值，大于0 表示向下拉动，借助css3 translateY属性使元素跟随手势向下滑动到对应的差值，同时也应设置一个允许滑动的最大值
3. 监听touchend事件，元素滑动到最大值，触发callback回调实现刷新，同时将translateY重新设为0,元素回到初始位置



下拉到松手过程经历的状态：

-  当前手势滑动位置与初始位置差值大于零时，提示正在进行下拉刷新操作； 	
-  下拉到一定值时，显示松手释放后的操作提示； 	
-  下拉到达设定最大值松手时，执行回调，提示正在进行更新操作。 	

**上拉加载：**

页面滚动到底部时触发，也可以选择在滚动到一定位置的时候触发；

实现原理：

获取当前滚动条的scrollTop值、当前可视范围的clientHeight，以及文档的总高度scrollHeight，当scrollTop+clientHeight>scrollHeight,触发回调

### 分页

方法一：组件用的是elementUI的分页组件，有两个事件监听页数的改变和size的改变，每次换页都调用接口，后端返回该的数据，请求数据的时候带上的是pagesize和currentpage

方法二：一次调用后端接口返回所有数据`tableData`，然后使用`tableData.slice((currentPage-1)*pageSize,currentPage*pageSize)`使得数据根据页码改变

### 对话框怎么实现 遮罩层

position z-index 

### 身份认证

**服务端渲染推荐使用session认证机制**

用户信息保存在服务器端

**前后端分离推荐使用JWT认证机制**

authorization字段 token 保存在浏览器端 



## 其他

#### 1、面向对象的三个特征，分别说一下什么意思 

封装、继承、多态

**封装：**把客观对象抽象成类，隐藏属性和方法的实现细节，仅对外公开接口，使得代码==**模块化**；==

**继承：** 继承可以解决==**代码复用**==，子类可以使用父类的功能，并且可以对这些功能进行扩展。让编程更加靠近人类思维。

**多态：** 是指接口的多种不同的实现方式。也可以理解成：多态是指通过指向父类的引用或指针，来调用在不同子类（派生类）中实现的方法。多态分为两种，一种是行为多态与对象的多态。**同一操作作用于不同的对象，可以有不同的解释，产生不同的执行结果。**

> 由于可以继承多个类，能够组合成多种特性，但多态的关键是覆盖，就是同一个方法可以用不同的方式去实现，展现出多态性。
>
> ==接口重用==

#### 1.1 面向对象编程与面向过程编程

解读：https://www.zhihu.com/question/21204750

**面向对象编程：**

- 三个特点：封装、继承、多态

- 主要特点是**类**，将所有需要执行的功能和函数拆分，进行分类，封装到不同的类中，程序执行过程中，通过不同的类的或类的对象调用不同的函数完成程序的运行。
- 把一个事件的执行过程变成了类和类中功能的交互，也就是不同对象之间的交互。通过对象来解决问题。
- 建立对象的目的不是为了完成某个步骤，而是为了描述某个事物在整个解决问题的步骤中的行为。
- 易维护、易扩展

**面向过程编程：**

- ==以过程为中心==的编程思想,分析出解决问题的步骤，用函数把这些步骤实现，然后==通过主函数按照顺序依次调用子函数一步步实现==

- 特点是 过程化和模块化，数据和对数据的操作是分离的。
- 执行效率高，面向过程不需要封装类再实例化调用，只用定义函数和调用，执行效率高一些。
- 不易维护

> 总结：两种编程方式主要是在于思考问题的方式不同，没有绝对的好与不好，关键在于问题的场景更适合用哪种思想。
>
> 对于简单应用场景：二者实现差别不大，但因为需求简单，相比之下面向过程编程更具有优势，只有一条主线，易划分步骤实现。
>
> 对于复杂应用场景：大规模程序开发，整个程序处理错综复杂，并非只有一条主线。面向对象更合适。
>
> 实际上，利用面向过程编程语言，我们照样可以写出面向对象编程风格的代码，只不过可能比用面向对象编程语言来写面向对象编程风格的代码付出的代价要高一些。而且，面向过程 编程和面向对象编程并非完全对立。在很多[软件](https://www.zhihu.com/search?q=软件&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra={"sourceType"%3A"answer"%2C"sourceId"%3A2531644986})开发中，尽管我们利用的是面向过程编程语 言，但也借鉴了面向对象编程的一些优点。



#### 2、前端自动化测试

测试分为：黑盒测试和白盒测试

自动化测试，主要指四个方向： **单元测试**、 **接口测试**、 **功能测试**、 **基准测试**。

前端测试主要分为 3 种：**单元测试（Unit Test）**、**集成测试（Integration Test）**、**UI 测试（UI Test）**

单元，能够理解为一个函数、一个react组件；接口即API，接口测试主要关注提供的接口是否可靠；功能能够理解为应用的UI、功能是否符合预期；基准测试能够帮咱们测试代码的性能。

市面上比较流行的前端测试框架有Mocha、QUnit、Jasmine、Jest等

![img](https://cdn.jsdelivr.net/gh/y3000/ImgRepo/img/202301311250987.png)

**TestCafe**是一款基于Node.js的端到端web自动化测试框架，支持TypeScript或JavaScript来编写测试用例，运行用例，并生成自动化测试报告。



#### 3、java和js的区别

**1.用处不一样：**

它们最本质的不同就是用途：Java目前被广泛应用于PC端、手机端、互联网、[数据中心](https://so.csdn.net/so/search?q=数据中心&spm=1001.2101.3001.7020)等等；

而JavaScript则被主要用于嵌入文本到HTML页面，读写HTML元素，控制cookies等。

**2.语言类型不同：**

JavaScript 是动态类型语言；而 Java 是静态类型语言。

Javascript 采用动态联编，即 Javascript 的对象引用在运行时进行检查。Java 采用静态联编，即 Java 的对象引用必须在编译时的进行，以使编译器能够实现强类型检查。

**3.所采取的变量不同：**

JavaScript 中的变量声明采用弱类型，即变量在使用前不需作声明，而是解释器在运行时检查其数据类型。Java 采用强类型变量检查，即所有变量在编译之前必须作声明。



**相似的地方：**

它们都是面向对象的（虽然实现的方式略有不同）；JavaScript 在设计时参照了 Java 的命名规则；

总而言之，JavaScript 除了长得和 Java 比较像之外，语言风格相去甚远。JavaScript 在设计时所参考的对象不包括 Java，而包括了像 Self 和 Scheme 这样的语言。

Java和JavaScript各有所长各有专精，Java的舞台在编程领域，而JavaScript的得心之处是在Web页面中，它几乎无所不能。

#### 4、java的继承和js的继承区别

- java里是没有多继承的，即一个子类不能同时继承多个父类，但可以实现多个接口，这也间接的实现了多继承。 

  关键字 extends 继承，implements 接口；使用 implements 关键字可以变相的使java具有多继承的特性，使用范围为类继承接口的情况，可以同时继承多个接口（接口跟接口之间采用逗号分隔）。

  接口是一些抽象方法的集合，编写接口时不需要实现方法，只需要声 明方法名即可，在需要使用接口提供的功能的类中去覆盖或实现这些方法,接口只是一个协议，继承接口了就必须实现接口内的所有方法。

- 而javascript是可以利用call方法和prototype属性来实现多继承的。继承方法与单继承相似，只是将需要继承的多个父类依次实现，另外对于属性或共有方法重命的时候，以最后继承的属性和方法为主。后面的会覆盖前面的继承：

#### 5、 js的严格模式限制

1.变量必须声明后再使用
2.函数的参数不能有同名属性，否则报错
3.不能使用with语句
4.不能对只读属性赋值，否则报错
5.不能使用前缀 0 表示八进制数，否则报错
6.不能删除不可删除的属性，否则报错
7.不能删除变量delete prop，会报错，只能删除属性delete global[prop]
8.eval不会在它的外层作用域引入变量
9.eval和arguments不能被重新赋值
10.arguments不会自动反映函数参数的变化
11.不能使用arguments.callee
12.不能使用arguments.caller
13.禁止this指向全局对象
14.不能使用fn.caller和fn.arguments获取函数调用的堆栈
15.增加了保留字（比如protected、static和interface）

#### 6、ommonJs和es module的区别

1. 两者的模块导入导出语法不同，CommonJs是通过`module.exports，exports`导出，`require`导入；ESModule则是`export`导出，`import导入`。
2. CommonJs是**运行时**加载模块，ESModule是在静态**编译**期间就确定模块的依赖。
3. CommonJs中顶层的this指向这个模块本身，而ESModule中顶层this指向undefined。
4. CommonJS加载的是整个模块，将所有的接口全部加载进来，ESModule可以单独加载其中的某个接口；
5. CommonJs导出的是一个**值的浅拷贝**，会对加载结果进行**缓存**，一旦内部再修改这个值，则**不会同步到外部**。ESModule是导出的一个**引用**，内部修改**可以同步**到外部。

> `Node` 是 CommonJS 在服务器端一个具有代表性的实现；
>
> `webpack` 打包工具对 CommonJS 的支持和转换；也就是前端应用也可以在编译之前，尽情使用 CommonJS 进行开发。
>
> （EsModel）所有通过 export 导出的属性，在 import 中可以通过结构的方式，解构出来。

##### import 可以做什么？

- 首先 `import()` 动态加载一些内容，可以放在条件语句或者函数执行上下文中。

  ```js
  if(isRequire){
      const result  = import('./b')
  }
  ```

  

- `import()` 可以实现懒加载，举个例子 vue 中的路由懒加载；

  ```js
  [
     {
          path: 'home',
          name: '首页',
          component: ()=> import('./home') ,
     },
  ]
  
  ```

#### 7、编译类型语言和解释类型语言有什么不同

编译类型语言：C/C++

- 执行速度快
- 内存消耗少
- 编译型程序不支持代码中实现安全性，一个编译型的程序可以访问内存的任何区域，并且可以对你的PC做它想做的任何事情（大部分病毒是使用编译型语言编写的）
- 程序体积大
- 编写难度高

解释类型语言：JAVA Python

- 执行速度慢
- 调试方便

- 平台独立性
- 安全性，适合Web应用开发
- 代码体积小

## 项目

### 1、项目中遇到问题？

[前端项目难点亮点 - 掘金 (juejin.cn)](https://juejin.cn/post/7074573053979525151)

1.**vue监听不到数组变化：**在通过更新表格数据时，遇到了明明数组输出是更新了的，但视图中还是原来的数据

解决办法：`this.$set(target, propertyName/index, value)`,Vue官方给出的一个api，可以让我们手动触发更新

> Vue 通过 `Object.defineProperty` 这个Api来进行对对象的响应式监听，对数组通过重写数组方法的方式来进行监听，而我们直接使用 `arr[0] = 123`  这种的索引方式来进行修改的时候他是监听不到了，那么我们需要使用**Vue.set()**这个方法来解决这个问题，当然这也是Vue2中才会出现的问题，Vue3中采用了  [Proxy](https://link.zhihu.com/?target=https%3A//developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Proxy)  的方式重写了响应式定义，也就不存在这个问题了，也提高了相应的性能。



**Proxy实现跨域（vue项目)**

在vue.config.js里面设置好proxy,里面写`'/api'{}`作为拦截，里面写好`target:后端的接口网址，``changeOrigin:true，pathRewrite:{}`

#### 修改elementUI的样式

- 深度选择器，/deep/，找到需要修改的组件标签的类名 在类名前加上deep ，可以强制修改默认样式，这种方式可以直接用到有 `scoped` 属性的 style 标签中。

- 在当前的vue单页面的`style`标签后，添加一对新的`style`标签，新的`style`标签中不要添加`scoped`属性。

  > 直接在里面修改第三方组件的样式，但是存在全局污染和命名冲突，约定的那个特殊的命名方式可以避免命名冲突

**Vuex 数据持久化**

将vuex中数据保存到sessionStorage

### 2、项目当中做过的性能优化

在小程序项目中 我们使用了懒加载来获取动态信息，一次仅请求10条 等滑到底部时再请求新的（onReachBottom）

节流 表单提交，防止短时间重复提交数据。

> 但是网络慢的时候，还是会重复提交，没有显示状态，用户不知道有没有真的提交。所以就给按钮添加一个加载状态，查了发现el-button自带了loading属性，传参的时候传一个submit函数，是一个Promise,promise状态改变的时候把loading状态改成false。然后点击按钮会有加载动画，加载的时候，按钮是禁用的。

搜索框搜索数据时使用防抖，对键盘keyUp 事件监听 

### 3、项目的难点、亮点

难点是实现**权限控制**，登录鉴权，菜单鉴权和按钮级鉴权

亮点就区别普通的后台管理系统，我们可以实现和用户的在线交流、我用 websocket实现了图表还有信息的实时更新。

难点也是 我们实现**websocket聊天功能** 长时间不操作 连接会不稳定，且会浪费资源，解决：每隔15min断开重新连接，避免浪费资源。

如果选择不断开的话 ，可以固定时间发送心跳包。

> 聊天记录列表是用v-for渲染的一个ul 列表：用v-if展示的不同的角色发的消息
>
> 挂载的时候连接websocket 传递参数是用户唯一标识，连接建立之后执行send方法发送数据
> 调接口获取一个聊天列表数据渲染在页面（后端是从redis里面）
>
> 数据动态展示 后端有数据更新就会推送，前端就通过onmessage监听 并根据字段判断数据类型进行更新 
>
> 长连接：心跳保活 （我们的做法是 15min不操作就会断开连接，避免消耗性能，相当于每隔15min就会重新连接一次）





我实现的后台管理系统，作为一个后台管理系统，比较重要的一项技术难点是实现权限控制。

> 在登录的时候拿到角色的权限路径，保存在（vuex）中，根据权限选择性的渲染生成可访问的菜单导航栏。
>
> 动态添加路由，拿到后端返回的权限路由，就用addRoutes动态添加，并存到VUEX中管理（渲染导航栏的时候从vuex中取出）
>
> 解决页面刷新时数据丢失：将vuex中数据保存到sessionStorage

> **按钮控制**
> 路由规则中可以增加路由元数据meta
> 通过路由对象可以得到当前的路由规则以及存在此规则中的meta 数据
> 自定义指令可以很方便的实现按钮控制



**疫情信息查询平台的上线bug:**

> 在本地调试模式下，用==proxy代理==方式解决了H5跨域请求，但运行在手机APP和微信小程序时，请求不到数据，这是因为在uni.request中，APP和微信小程序需要写完整地址
>
> 小程序端是自带跨域解决的，但请求的URL必须是完整的，而H5跨域转发用代理，在mainifest.json或者新建vue.config.js配置proxy代理转发即可

> 小程序端跨域和H5跨域，用**条件编译解决**



**小程序上线遇到的bug：体积过大，无法预览或上传**

> 解决：压缩static中的图片，删除不必要的图片，最关键的是，map.json这个文件有400多kb,但是开发人员将它放到static文件（静态资源最好只能放图片图标视频，但放了一个JSON文件）里面就没办法压缩，所以把它移到component文件夹下面，解决体积过大的问题。

> 期间还用了这些办法解决包体积大的问题：

- 分包，在pages.json中配置：(有效果，但不大，因为本来pages文件就不大，大的是echart.min.js和map.json 这两个文件，不过这个方法可行)

- 自定配置echarts，缩小插件体积：替换`echarts.min.js`

  到官网去配置

- 勾选一些配置（H运行到微信开发者）以及微信开发者工具中的基本配置（管用）



### 项目做了哪些安全措施：

**登录时的数据传输：** 加密传输（一次加盐加密，然后再加密 base64编码）用户名密码 ，后端拿到数据后按照解密方式解密后验证成功返回token ，存入 sessionstorage，每次请求会带上token。

axios的请求拦截器，在请求头添加自定义的一个字段 authorization ，将sessionstorage的token存进去，

**xss防御**： 在所有用户有输入的地方做了脚本字符串过滤，不信任用户的任何输入。

> cookie设置httponly和secure；
>
> httponly：该属性会禁止JS脚本使用document.cookie来访问cookie，有效防止xss攻击
>
> secure：该属性告诉浏览器仅在请求为HTTPS连接的时候才发送cookie



亮点：
富文本？

问题：**富文本数据存储传输**

html的标签特殊字符转换成普通字符，用的时候再转出来











### 4、项目中使用防抖、节流优化没

节流 表单提交，防止短时间重复提交数据

搜索框搜索数据时使用防抖，对键盘keyUp 事件监听 

### 5、说一说项目

首先我做过的软件售后服务系统他是一个面向软件公司用户和技术人员的系统，所以分为前台一个售后系统，提供一个用户可以提出自己购买的产品的问题问题反馈平台，也有一个简易的客服聊天功能，后台管理系统面向技术人员和超级管理员，技术人员主要是对用户提出的问题进行解决并反馈，实时更新问题解决进度。

后台管理系统除了提供数据的管理（增删改查）之外，像是产品和用户的信息管理，主要的业务就是对用户提出的问题提交解决方案，还有就是回复的在线消息

websocket 提供聊天和消息

rbac权限控制 实现了动态菜单 ，在登陆请求时会得到权限数据，展示对应的菜单。（不同用户的菜单列表不一样），将菜单存在vuex里面的，在created的时候就对菜单进行渲染

路由拦截 用户没有登录强行在URL地址进入首页 会跳到登录页面

或者用户已登录去到权限外或者没有的地址会跳到404页面

我的不足就是 在按钮功能的权限控制没有在前端响应出来，点击权限之外的按钮还是会发送请求，但是会告诉用户权限不足，我觉得应该对非权限的按钮直接处于禁用状态或者 不显示，而且要拦截请求，避免不必要的请求。

以及动态路由的实现 

用户的登录信息保存在sessionstorage里面，因为安全，或者localstorage也行



其他的项目： 静态的商场页面 品优购 学习jscss时候写的

其他的vue项目 目前这个阶段仍在学习中 vue 和react结合起来学习  





音乐项目实现了 歌曲歌单歌手广场 和个人信息

歌曲播放和切换，歌手关注，歌曲评论分享收藏 歌单分类，排行榜展示

评论做了过滤 微信的 msgSecCheck  在前端给用户提示

### 6、项目的收获

熟悉vue项目 开发流程，学习到了新的技术 websocket和eachart 增强了团队合作能力，

软件售后服务系统呢是从项目需求开发，到架构设计，到原型开发编码测试一系列过程 对软件项目的生命周期有一个深刻的认知





webpack  只做过配置



具体介绍一下简历上的项目



### 平时如何学习

通过项目学习，还有网上的视频资源 看过黑马的前端基础视频 学习三件套基础的时候.案例demo 上手

书籍红宝书、



职业规划

入职的近一两年内潜心提升技术，提升自己的阅历，利用平台给我机会开拓视野，在前端领域进阶发展，后面熟悉公司业务熟悉项目流程，向产品岗或者管理岗进阶，利用的自己经验带领新人发展公司。

为什么没有实习

首先大一能力不足还没有明确前端的方向，大一大二课程紧张，时间不富余，利用了大二的暑假学习前端基础，大三上完成课程项目 学习vue框架 ，这个学期学校安排了一个实习公司 实习开发项目流程，开发微信小程序，现在把握提前批的机会 为自己争取offer， 加紧学习，丰富项目经历



性格的优缺点 

我可能在创新方面缺乏知识，由于经验的缺乏以及知识的广度的方面的欠缺，可能目前来说对问题的考虑欠缺的全面性，不过我相信通过之后的工作和不断学习，拓宽知识的广度，不局限于单一框架里面，对事物和问题的认识会更加丰富。

## 面试技巧

### 自我介绍

面试官您好，我叫杨芊，应聘的是前端开发工程师的岗位，我来自四川师范大学软件工程专业，目前是大四在读，在校期间获得过三等奖学金和国家励志奖学金，参加过一些学科竞赛，在去年和今年的蓝桥杯比赛中取得过省三和省二的成绩；从正式接触前端到现在一年多的时间，期间学习了前端三件套HTML、CSS、JS的基础，了解了ES6新特性，在大三的时候，自学了Vue框架，结合Vue框架和ElementUI框架开发了一个软件售后服务系统，我在这个项目中主要负责的是后台管理端相关的页面和功能；在后面也参加了学校组织公司实训，实训中我选择方向的是微信小程序开发，使用uniapp框架开发了一个云音乐小程序。现在呢，我也在不断学习前端领域相关知识，目前自学了一些node.js的基础，可以使用express框架结合mysql数据库编写简单的接口；然后最近也参加了阿里终端练习生计划这样一个学习青训营，在项目小组中作为组长的角色带领组员一起完成了一个疫情信息可视化平台，使用uniapp框架实现了跨端兼容，同时兼容微信小程序和PC端；我的职业规划方也是前端开发，之所以选择前端开发方向， 是因为我对前端方向比较感兴趣，可以作为动力促进我不断学习进步。



### 职业发展

#### **1、为什么选择前端**

前端实现页面带来成就感，快乐，看得见的效果  ，比较感兴趣，不枯燥，觉得自己适合。

#### **2、怎么学习前端的，有没有系统学习过前端**

我最开始接触前端方向时大二的时候，在小组合作实训项目时，我对前端方向比较感兴趣，主动承担了前端方向的一些工作，后面利用大二下的暑假，我系统的学习了HTML、CSS/js基础，通过视频教程和红宝书学习，然后练习一些静态布局，模仿静态商城之类的，然后大三的时候，有老师给我们布置项目，然后为了更好的完成这个项目，我又去学习了vue框架，然后这个软件售后服务系统就是利用vue结合elementUI框架完成的，通过这个项目也提升了自己的前端开发能力。然后我对小程序开发也比较感兴趣，就在5月份实训中选择了微信小程序的实训方向，使用的是uniapp框架，之前也用过微信小程序原生框架开发。现在自学了一些node相关的基础知识，了解了node作为js开发服务端的一些基本应用。

   

学校没有开设前端知识相关的太多课程，那我大部分都是利用业余时间通过网上的一些课程资源，项目上手，实践是检验真理唯一标准，遇到需要知识点就与看开发者手册，看不懂就去看帖子，再不济就与搜索相关的视频教程，有些功能点做不出来就去参考开源项目。



#### **3、学过哪些框架**

前端框架主要就是vue

UI 框架使用过：elementUI、Ant-design,开发小程序使用过vant UI



认为前端比较厉害的技术（印象深刻的技术）

前端处于猛烈发展阶段

作为一个前端你认为应该掌握哪些知识



#### **4、未来三年职业规划**

首先熟悉公司实际项目流程，掌握开发技能，从初级前端工程师养成到高级前端工程到资深前端工程师，学习前沿技术，在前端领域深入研究发展 后续的话在熟悉项目开发各种大小事宜后，争取走向产品岗或者管理岗位，带领新人发展技术。

#### **5、你觉得你的优点是什么？**

自学能力强，前端的知识大部分是自学的；

适应能力强，快速适应环境；

自律能力强，有目标，清晰的规划；

有责任心，交付的任务一定会去完成；

良好的沟通和表达能力，在团队当中能够进行协作。



#### 6、你有什么兴趣爱好？

平时喜欢音乐，学过吉他，平时会练一些简单的弹唱谱子，我喜欢Jam这个民谣歌手，所以我也会去学了她的一首歌《七月上》《差三岁》；

在学习过程中喜欢写文档记录，有创建自己的CSDN博客，也搭建过个人的静态博客网站。

对前端领域感兴趣，所以会去参加像字节青训营和阿里终端练习生计划这样的训练营提升自己。









你未来的一个职业规划是什么？
你都是怎么去学习和关注新技术的？



你近几年工作中有哪些心得或总结？





你过来我们公司，你的优势是什么？（你能为公司带来什么？）

 你在工作中遇到过哪些难点。



- 投过的公司和部门 手上有什么其他的offer

字节跳动，四面之后可能还是觉得不合适吧，泡了很久的池子之后就收到感谢信了。

有一个北京易华录公司的，因为给的是实习岗位所以就没有考虑了。然后其他的都还在流程中，笔试这些，暂时还没有明确的offer ；

有一个意向，有两家还在流程中。

- 你能为公司带来什么

  



hr面

前面三面感觉





- 你认为你最擅长什么 前端，根据原型图快速梳理页面布局，还原页面
- 

### 反问

1、你有什么要问我的

**技术面试官：**

- 对于我有什么好的建议，如何更好的在前端领域提升自己
- 前端领域日新月异，如何学习方法
- **部门岗位的技术栈**，我学的vue对工作会有影响吗（如果是react的话）
- 一个团队的规模如何，一般是怎样分工的呢
- 公司内部对于技术员工的成长路径大概是什么样子？
- **部门业务**，在这个岗位上，会直接接触到哪些类型的项目？
- 对于该岗位，贵公司或者学长最看重的一个技能点是什么？ 

**hr面试官**

- 这个岗位如何评估绩效，试用期需要达到什么指标？
- 公司的文化氛围是什么样的？
- 对于应届毕业生的培养方案时怎样的 *
- 公司的晋升机制是什么样的？
- 绩效考核是怎样的，一般有多少人能拿到合格的绩效呢
- hr面可以问薪酬结构福利待遇，但是**校招就不建议问**了，因为是固定的
- 公司的考勤和作息时间一般是怎样的
- 是否能分享一下您在xx公司的工作体会？
- 公司在过去一年的发展怎么样？接下来关注的目标是什么？

### 非技术问题

- Q：你有什么缺点？

  A：我觉得我的缺点是实践经验不足，在学校里学习的知识都是一些陈旧和基础的知识，而实际工作中用到的都是前沿的新技术，这可能会让我在初期的工作中比较吃力，加上我自己的性格有时候会比较执着，就会导致为一些技术问题加班到深夜。另外我可能缺乏一些创新性思维，总是按部就班地完成任务。这些问题我想我可以进入公司后通过磨合以最短的时间来解决。我的学习能力和适应能力很强，我相信可以短期内尽快补足技术短板，融入公司氛围、进入工作状态。

  （从自己的优点说起，中间加一些小缺点，最后再把问题转到优点上来）

- Q：对加班的看法？

  A：如果是因为项目进度需求，我会义不容辞，目前没有家庭负担，可以全身心投入工作。但同时，因为刚走出校园又缺乏工作经验的原因，可能会因为个人能力问题导致不能按时完工而加班，如果是这样的话，我会努力利用休息时间尽快提升自己的技术能力，尽快熟悉业务、提高自己工作效率，减少不必要的加班。

  （并不一定非要加班，面试官只是想测试一下你是否愿意为公司奉献）

- Q：之后的职业规划？

  （问题的背后是了解你的求职动机和对自己中长期职业发展的思考）

- Q：说说你对行业、技术发展趋势的看法。

  （有备而来。只有深入了解才能产生独特见解。公司欢迎进入公司的人是“知己”，而不是“盲人”）

- Q：对薪资的要求？

  A：我对工资没有硬性要求，我相信公司在处理我的薪资问题上会友善合理。目前我更注重的是找对工作机会和企业平台，所以只要条件公平，我不会计较太多。

  （对薪资要求太低显然贬低自己的能力，要求太高又会显得自不量力；面试官这么问只不过为了证实这份钱是否足够引起你对该工作的兴趣）

- Q：什么时候能入职？

  （面试官最希望听到的回答是“如果被录用的话，到职日可按公司的规定上班”）

- Q：如果公司录用你，你将如何开展工作？

  A：我想我首先应当了解部门在整个公司中的地位，以及部门的工作目标，从而确定自身的工作努力方向。其次，还要对部门的主营业务有一个充分认知，熟悉团队的业务组成部分、业务发展方向、客户群体性质等。最后，学习项目常用的开发框架和技术，利用入职前的空档期和平日休息时间尽快补足知识技术上的短板，紧密配合其他同事的工作，尽快投入到具体的开发任务中来。

  （“实打实”回答，表明自己是个稳扎稳打的人）

- Q：你对我们公司了解多少？

  （公司招聘官网上一般都有“企业文化”、“了解我们”之类的宣传栏，面试前去看一看）

- Q：平时有什么兴趣爱好？

  （说一些富于团队合作精神的，尽量不要说单人活动）
  
  和朋友一起王者峡谷开黑。吉他。



